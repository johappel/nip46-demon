import { parseTagsJson, pushOptionalTag, resolveKindWithSelector } from "./shared.js";

/**
 * Reads the first non-empty value from candidate field names.
 * @param {Record<string,string>} values - Collected form values.
 * @param {string[]} candidateKeys - Candidate field keys.
 * @returns {string} First non-empty normalized value.
 */
function readFirstValue(values, candidateKeys) {
    for (const key of candidateKeys) {
        const value = String(values?.[key] || "").trim();
        if (value) return value;
    }
    return "";
}

/**
 * Parses comma/newline separated topic list into `t` tags.
 * @param {Record<string,string>} values - Collected form values.
 * @returns {string[][]} Topic tags.
 */
function parseTopicTags(values) {
    const rawTopics = readFirstValue(values, ["topics"]);
    if (!rawTopics) return [];

    const seen = new Set();
    const tags = [];
    const parts = rawTopics
        .split(/[\n,]/g)
        .map((entry) => String(entry || "").trim())
        .filter(Boolean);

    for (const topic of parts) {
        const normalized = topic.toLowerCase();
        if (seen.has(normalized)) continue;
        seen.add(normalized);
        tags.push(["t", topic]);
    }

    return tags;
}

/**
 * Filters user-provided JSON tags.
 * `published_at` is intentionally excluded because it is generated by runtime.
 * @param {string[][]} rawTags - Parsed tags from JSON input.
 * @returns {string[][]} Allowed tags.
 */
function filterUserProvidedJsonTags(rawTags) {
    return rawTags.filter((tag) => {
        const tagName = String(tag?.[0] || "").toLowerCase();
        if (!tagName) return false;
        return tagName !== "published_at";
    });
}

/**
 * Builds a NIP-23 long-form event (publish/draft).
 * For publish mode (`kind:30023`) `published_at` is generated automatically.
 * @param {import("./shared.js").BuildEventContext} context - Build context.
 * @returns {object} Unsigned nostr event.
 */
export function buildNip23UnsignedEvent(context) {
    const schema = context.schema;
    const values = context.values;
    const kind = resolveKindWithSelector(schema, values);
    const nowUnix = Math.floor(Date.now() / 1000);
    const identifier = readFirstValue(values, ["identifier", "slug", "title"]) || "entry";
    const title = readFirstValue(values, ["title"]);
    const summary = readFirstValue(values, ["summary"]);
    const image = readFirstValue(values, ["image"]);
    const content = readFirstValue(values, ["content", "description"]);

    const tags = [];
    pushOptionalTag(tags, "d", identifier);
    pushOptionalTag(tags, "title", title);
    pushOptionalTag(tags, "summary", summary);
    pushOptionalTag(tags, "image", image);
    if (kind === 30023) {
        pushOptionalTag(tags, "published_at", String(nowUnix));
    }
    tags.push(...parseTopicTags(values));
    tags.push(...filterUserProvidedJsonTags(parseTagsJson(values)));

    return {
        kind,
        created_at: nowUnix,
        tags,
        content,
        pubkey: context.pubkey
    };
}

