<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NIP-46 Send Event Test</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: #121212;
            color: #fff;
            max-width: 900px;
            margin: 0 auto;
        }
        .card {
            background: #1d1d1d;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 14px;
        }
        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input, textarea, button {
            width: 100%;
            box-sizing: border-box;
            border-radius: 8px;
            border: 1px solid #444;
            background: #0f0f0f;
            color: #fff;
            padding: 10px;
            margin-bottom: 10px;
        }
        textarea {
            min-height: 110px;
            resize: vertical;
        }
        button {
            cursor: pointer;
            border: none;
            background: #2a7fff;
            font-weight: 700;
        }
        button[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
        }
        .ok { color: #7ee787; }
        .err { color: #ff7b72; }
        #embed-signer {
            width: auto;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <h1>NIP-46 Sender</h1>

    <div class="card">
        <label class="label" for="signer-url">Signer URL (iframe)</label>
        <input id="signer-url" value="./signer.html" />
        <label>
            <input type="checkbox" id="embed-signer" checked style="width:auto; margin-right:8px;">
            Signer eingebettet starten (empfohlen)
        </label>
        <button id="sync-iframe-btn">Connection URI aus iframe holen</button>
        <iframe id="signer-frame" title="Signer" src="./signer.html" style="width:100%; height:300px; border:1px solid #333; border-radius:8px; margin-top:10px;"></iframe>
    </div>

    <div class="card">
        <label class="label" for="conn-uri">Connection URI</label>
        <input
            id="conn-uri"
            value=""
            placeholder="nostrconnect://<pubkey>?relay=wss%3A%2F%2F..."
        />
        <button id="connect-btn">Mit Signer verbinden</button>
        <div id="status">Nicht verbunden</div>
        <pre id="user"></pre>
    </div>

    <div class="card">
        <label class="label" for="wp-user-id">WordPress userId</label>
        <input id="wp-user-id" value="123" placeholder="z.B. 123 oder user@example.com" />
        <button id="wp-ensure-key-btn">WP-Key sicherstellen (userId -&gt; pubkey)</button>
        <pre id="wp-result"></pre>
    </div>

    <div class="card">
        <label class="label" for="content">Event-Content (Kind 1)</label>
        <textarea id="content">Hallo von sendevent.html</textarea>
        <button id="send-btn" disabled>Event senden</button>
        <pre id="result"></pre>
    </div>

    <script type="module">
        import NDK, { NDKEvent, NDKNip46Signer, NDKPrivateKeySigner, NDKRelaySet } from "https://esm.sh/@nostr-dev-kit/ndk@3.0.0?bundle&target=es2022";

        const NSEC_STORAGE_KEY = "nip46_demo_nsec";
        const BRIDGE_SOURCE = "nip46-signer-bridge";
        const DEFAULT_RELAYS = [
            "wss://relay.damus.io",
            "wss://nos.lol",
            "wss://relay.primal.net",
            "wss://relay.snort.social"
        ];
        const MIN_SIGNER_FRAME_HEIGHT = 110;
        const MAX_SIGNER_FRAME_HEIGHT = 1200;
        const connInput = document.getElementById("conn-uri");
        const signerUrlInput = document.getElementById("signer-url");
        const embedSignerInput = document.getElementById("embed-signer");
        const syncIframeBtn = document.getElementById("sync-iframe-btn");
        const signerFrame = document.getElementById("signer-frame");
        const connectBtn = document.getElementById("connect-btn");
        const sendBtn = document.getElementById("send-btn");
        const wpUserIdInput = document.getElementById("wp-user-id");
        const wpEnsureKeyBtn = document.getElementById("wp-ensure-key-btn");
        const wpResultEl = document.getElementById("wp-result");
        const statusEl = document.getElementById("status");
        const userEl = document.getElementById("user");
        const resultEl = document.getElementById("result");
        const contentEl = document.getElementById("content");

        let ndk;
        let signer;
        let signerFrameOrigin = null;
        let lastBridgeConnectionInfo = null;
        let activeRelayUrls = [];
        let currentSignerFrameHeight = MIN_SIGNER_FRAME_HEIGHT;

        function toBunkerUri(uri, relays = []) {
            const url = new URL(uri);

            if (url.protocol === "bunker:") {
                const pubkey = url.hostname || url.pathname.replace(/^\/+/, "");
                const out = new URLSearchParams(url.searchParams);
                const mergedRelays = new Set([...out.getAll("relay"), ...relays]);
                out.delete("relay");
                for (const relay of mergedRelays) out.append("relay", relay);
                const qs = out.toString();
                return `bunker://${pubkey}${qs ? `?${qs}` : ""}`;
            }

            if (url.protocol !== "nostrconnect:") {
                throw new Error("URI muss mit nostrconnect:// oder bunker:// beginnen.");
            }

            const pubkey = url.hostname || url.pathname.replace(/^\/+/, "");
            if (!pubkey) throw new Error("Kein Pubkey in URI gefunden.");

            const out = new URLSearchParams();
            const mergedRelays = new Set([...url.searchParams.getAll("relay"), ...relays]);
            for (const relay of mergedRelays) out.append("relay", relay);

            const secret = url.searchParams.get("secret");
            if (secret) out.set("secret", secret);

            const qs = out.toString();
            return `bunker://${pubkey}${qs ? `?${qs}` : ""}`;
        }

        function relayUrlsFromUri(uri) {
            const url = new URL(uri);
            const relays = url.searchParams.getAll("relay");
            const merged = new Set([
                ...relays,
                ...DEFAULT_RELAYS
            ]);
            return Array.from(merged);
        }

        function canonicalRelayUrl(url) {
            try {
                return new URL(url).toString().replace(/\/$/, "");
            } catch (_err) {
                return String(url || "");
            }
        }

        function uniqueRelayUrls(relays) {
            const map = new Map();
            for (const relay of relays || []) {
                const key = canonicalRelayUrl(relay);
                if (!key) continue;
                if (!map.has(key)) map.set(key, relay);
            }
            return Array.from(map.values());
        }

        async function hydrateUriFromLocalSigner() {
            const nsec = localStorage.getItem(NSEC_STORAGE_KEY);
            if (!nsec || !nsec.startsWith("nsec1")) return;

            try {
                const localSigner = new NDKPrivateKeySigner(nsec);
                const user = await localSigner.user();
                const relayQuery = [
                    ...DEFAULT_RELAYS.map((relay) => "relay=" + encodeURIComponent(relay))
                ].join("&");
                connInput.value = `nostrconnect://${user.pubkey}?${relayQuery}`;
            } catch (_err) {
                // ignore: if nsec invalid, keep default URI
            }
        }

        function setStatus(text, isError = false) {
            statusEl.textContent = text;
            statusEl.className = isError ? "err" : "ok";
        }

        function clampSignerFrameHeight(height) {
            return Math.max(MIN_SIGNER_FRAME_HEIGHT, Math.min(MAX_SIGNER_FRAME_HEIGHT, height));
        }

        function applySignerFrameHeight(height) {
            const numeric = Number(height);
            if (!Number.isFinite(numeric)) return;
            const px = Math.round(clampSignerFrameHeight(numeric));
            if (Math.abs(px - currentSignerFrameHeight) < 2) return;
            currentSignerFrameHeight = px;
            signerFrame.style.height = `${px}px`;
        }

        function buildSignerFrameSrc(rawUrl) {
            const signerUrl = new URL(rawUrl, window.location.href);
            signerUrl.searchParams.set("parentOrigin", window.location.origin);
            return signerUrl;
        }

        function refreshSignerFrame() {
            try {
                const signerUrl = buildSignerFrameSrc(signerUrlInput.value.trim() || "./signer.html");
                signerFrameOrigin = signerUrl.origin;
                signerFrame.src = signerUrl.toString();
                applySignerFrameHeight(MIN_SIGNER_FRAME_HEIGHT);
                signerFrame.style.display = embedSignerInput.checked ? "block" : "none";
            } catch (err) {
                console.error(err);
                setStatus(`Ungültige Signer-URL: ${err.message}`, true);
            }
        }

        function applyConnectionInfo(info) {
            if (!info) return;
            if (typeof info.nostrconnectUri === "string" && info.nostrconnectUri.startsWith("nostrconnect://")) {
                connInput.value = info.nostrconnectUri;
            }
            lastBridgeConnectionInfo = info;
        }

        function requestConnectionInfoFromIframe(timeoutMs = 3000) {
            return new Promise((resolve, reject) => {
                if (!embedSignerInput.checked || !signerFrame.contentWindow) {
                    reject(new Error("Signer-iframe nicht aktiv."));
                    return;
                }
                if (!signerFrameOrigin) {
                    reject(new Error("Signer-Origin unbekannt."));
                    return;
                }

                const timeout = setTimeout(() => {
                    window.removeEventListener("message", onMessage);
                    reject(new Error("Keine Bridge-Antwort vom Signer-iframe."));
                }, timeoutMs);

                function onMessage(event) {
                    if (event.origin !== signerFrameOrigin) return;
                    const data = event.data;
                    if (!data || data.source !== BRIDGE_SOURCE) return;
                    if (data.type === "frame-size") {
                        applySignerFrameHeight(data.payload?.height);
                        return;
                    }
                    if (data.type !== "ready" && data.type !== "connection-info" && data.type !== "locked") return;

                    clearTimeout(timeout);
                    window.removeEventListener("message", onMessage);
                    if (data.type === "locked") {
                        reject(new Error(data.payload?.reason || "Signer ist gesperrt."));
                        return;
                    }
                    resolve(data.payload);
                }

                window.addEventListener("message", onMessage);
                signerFrame.contentWindow.postMessage(
                    { source: BRIDGE_SOURCE, type: "get-connection-info" },
                    signerFrameOrigin
                );
            });
        }

        function bridgeMessageHandler(event) {
            if (!signerFrameOrigin || event.origin !== signerFrameOrigin) return;
            const data = event.data;
            if (!data || data.source !== BRIDGE_SOURCE) return;
            if (data.type === "frame-size") {
                applySignerFrameHeight(data.payload?.height);
                return;
            }
            if (data.type !== "ready" && data.type !== "connection-info" && data.type !== "locked") return;

            if (data.type === "locked") {
                setStatus(`Signer gesperrt: ${data.payload?.reason || "Bitte entsperren."}`, true);
                return;
            }

            applyConnectionInfo(data.payload);
            setStatus("Signer bereit (Bridge).");
        }

        function requestWpUserKeyFromIframe(userId, timeoutMs = 6000) {
            return new Promise((resolve, reject) => {
                if (!embedSignerInput.checked || !signerFrame.contentWindow) {
                    reject(new Error("Signer-iframe nicht aktiv."));
                    return;
                }
                if (!signerFrameOrigin) {
                    reject(new Error("Signer-Origin unbekannt."));
                    return;
                }

                const trimmedUserId = String(userId || "").trim();
                if (!trimmedUserId) {
                    reject(new Error("Bitte userId eingeben."));
                    return;
                }

                const requestId = `wp_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 9)}`;
                const timeout = setTimeout(() => {
                    window.removeEventListener("message", onMessage);
                    reject(new Error("Keine Antwort vom Signer auf wp-ensure-user-key."));
                }, timeoutMs);

                function onMessage(event) {
                    if (event.origin !== signerFrameOrigin) return;
                    const data = event.data;
                    if (!data || data.source !== BRIDGE_SOURCE) return;
                    if (data.type === "frame-size") {
                        applySignerFrameHeight(data.payload?.height);
                        return;
                    }
                    if (data.type !== "wp-user-key-result") return;
                    if (data.payload?.requestId !== requestId) return;

                    clearTimeout(timeout);
                    window.removeEventListener("message", onMessage);
                    if (!data.payload?.ok) {
                        reject(new Error(data.payload?.error || "WP-Key konnte nicht erstellt werden."));
                        return;
                    }
                    resolve(data.payload);
                }

                window.addEventListener("message", onMessage);
                signerFrame.contentWindow.postMessage(
                    {
                        source: BRIDGE_SOURCE,
                        type: "wp-ensure-user-key",
                        payload: { requestId, userId: trimmedUserId }
                    },
                    signerFrameOrigin
                );
            });
        }

        async function ensureWpKeyForUser() {
            try {
                wpResultEl.textContent = "Fordere WP-Key vom Signer an...";
                const result = await requestWpUserKeyFromIframe(wpUserIdInput.value, 7000);
                wpResultEl.textContent = JSON.stringify(result, null, 2);
                const mode = result.existed ? "bereits vorhanden" : "neu erzeugt";
                setStatus(`WP-Key ${mode}: ${result.pubkey.slice(0, 12)}...`);
            } catch (err) {
                wpResultEl.textContent = `Fehler: ${err.message}`;
                setStatus(`WP-Key Fehler: ${err.message}`, true);
            }
        }

        function withTimeout(promise, ms, stepName) {
            let timer;
            const timeoutPromise = new Promise((_, reject) => {
                timer = setTimeout(() => {
                    reject(new Error(`${stepName} Timeout nach ${ms}ms`));
                }, ms);
            });

            return Promise.race([promise, timeoutPromise]).finally(() => {
                clearTimeout(timer);
            });
        }

        function patchRpcSubscribeNoEose(nip46Signer) {
            const rpc = nip46Signer?.rpc;
            if (!rpc || rpc.__noEosePatched) return;

            const originalSubscribe = rpc.subscribe?.bind(rpc);
            if (typeof originalSubscribe !== "function") return;

            rpc.subscribe = function subscribeNoEose(filter) {
                return new Promise((resolve) => {
                    const sub = this.ndk.subscribe(filter, {
                        closeOnEose: false,
                        groupable: false,
                        cacheUsage: "ONLY_RELAY",
                        pool: this.pool,
                        relaySet: this.relaySet,
                        onEvent: async (event) => {
                            try {
                                const parsedEvent = await this.parseEvent(event);
                                if (parsedEvent.method) {
                                    this.emit("request", parsedEvent);
                                } else {
                                    this.emit(`response-${parsedEvent.id}`, parsedEvent);
                                    this.emit("response", parsedEvent);
                                }
                            } catch (e) {
                                this.debug?.("error parsing event", e, event.rawEvent?.());
                            }
                        }
                    });
                    resolve(sub);
                });
            };

            rpc.__noEosePatched = true;
            rpc.__originalSubscribe = originalSubscribe;
        }

        function connectedRpcRelayCount(nip46Signer) {
            const relaysMap = nip46Signer?.rpc?.pool?.relays;
            if (!relaysMap || typeof relaysMap.values !== "function") return 0;
            return Array.from(relaysMap.values()).filter((relay) => relay?.status === 5).length;
        }

        async function ensureRpcRelaysConnected(nip46Signer, timeoutMs = 8000, minConnected = 1) {
            const rpcPool = nip46Signer?.rpc?.pool;
            if (!rpcPool || typeof rpcPool.connect !== "function") return;

            await withTimeout(rpcPool.connect(timeoutMs), timeoutMs + 1500, "rpc pool connect");

            const connected = connectedRpcRelayCount(nip46Signer);
            if (connected < minConnected) {
                throw new Error(`Keine RPC-Relay-Verbindung (${connected}/${minConnected})`);
            }
        }

        function enforceRelayAllowlist(nip46Signer, allowedRelays) {
            const allowed = new Set(uniqueRelayUrls(allowedRelays).map(canonicalRelayUrl));

            if (typeof nip46Signer.switchRelays === "function") {
                nip46Signer.switchRelays = async () => {};
            }

            const rpc = nip46Signer?.rpc;
            if (!rpc) return;

            if (typeof rpc.updateRelays === "function") {
                const originalUpdateRelays = rpc.updateRelays.bind(rpc);
                rpc.updateRelays = (urls) => {
                    const filtered = uniqueRelayUrls((urls || []).filter((u) => allowed.has(canonicalRelayUrl(u))));
                    if (filtered.length === 0) return;
                    originalUpdateRelays(filtered);
                };
            }
        }

        function buildFixedRelaySet(ndkInstance, relays) {
            const relayObjs = uniqueRelayUrls(relays)
                .map((url) => ndkInstance.pool.getRelay(url, true, false))
                .filter(Boolean);
            return new NDKRelaySet(new Set(relayObjs), ndkInstance, ndkInstance.pool);
        }

        async function connectSigner() {
            try {
                setStatus("Verbinde...");
                resultEl.textContent = "";

                let bridgeInfo = null;
                if (embedSignerInput.checked) {
                    try {
                        bridgeInfo = await requestConnectionInfoFromIframe();
                        applyConnectionInfo(bridgeInfo);
                    } catch (err) {
                        setStatus(`Signer nicht bereit: ${err.message}`, true);
                        return;
                    }
                }

                let relays;
                let bunkerUri;

                if (bridgeInfo?.bunkerUri && Array.isArray(bridgeInfo?.relays) && bridgeInfo.relays.length > 0) {
                    relays = uniqueRelayUrls(bridgeInfo.relays);
                    bunkerUri = bridgeInfo.bunkerUri;
                    resultEl.textContent = "Bridge-Connection-Info wird verwendet.";
                } else if (lastBridgeConnectionInfo?.bunkerUri && Array.isArray(lastBridgeConnectionInfo?.relays) && lastBridgeConnectionInfo.relays.length > 0) {
                    relays = uniqueRelayUrls(lastBridgeConnectionInfo.relays);
                    bunkerUri = lastBridgeConnectionInfo.bunkerUri;
                    resultEl.textContent = "Zuletzt bekannte Bridge-Connection-Info wird verwendet.";
                } else {
                    const rawUri = connInput.value.trim();
                    relays = uniqueRelayUrls(relayUrlsFromUri(rawUri));
                    bunkerUri = toBunkerUri(rawUri, relays);
                    resultEl.textContent = "URI aus Eingabefeld wird verwendet.";
                }
                activeRelayUrls = relays;

                ndk = new NDK({ explicitRelayUrls: relays });
                setStatus(`Verbinde ueber: ${relays.join(", ")}`);
                await withTimeout(ndk.connect(), 10000, "relay connect");

                signer = NDKNip46Signer.bunker(ndk, bunkerUri);
                patchRpcSubscribeNoEose(signer);
                enforceRelayAllowlist(signer, relays);
                setStatus("Verbinde RPC-Relays...");
                await ensureRpcRelaysConnected(signer, 8000, 1);
                let user;
                try {
                    setStatus("NIP-46 Handshake läuft...");
                    user = await withTimeout(signer.blockUntilReady(), 12000, "nip46 connect");
                } catch (handshakeErr) {
                    console.warn("Handshake fehlgeschlagen, fallback aktiv:", handshakeErr);
                    resultEl.textContent = `Handshake fehlgeschlagen (${handshakeErr.message}), nutze Fallback...`;
                    setStatus("Fallback: Direktmodus...");

                    if (typeof signer.startListening === "function") {
                        await withTimeout(signer.startListening(), 5000, "startListening");
                    }

                    let pubkey = bridgeInfo?.pubkey || lastBridgeConnectionInfo?.pubkey;
                    if (!pubkey && typeof signer.getPublicKey === "function") {
                        pubkey = await withTimeout(signer.getPublicKey(), 8000, "get_public_key");
                    }
                    if (!pubkey) throw handshakeErr;

                    if ("userPubkey" in signer) signer.userPubkey = pubkey;
                    if ("_user" in signer) signer._user = ndk.getUser({ pubkey });
                    user = ndk.getUser({ pubkey });
                }

                setStatus("Verbunden");
                userEl.textContent = `npub: ${user.npub}\npubkey: ${user.pubkey}\nrelay: ${relays.join(", ")}`;
                sendBtn.disabled = false;
            } catch (err) {
                console.error(err);
                sendBtn.disabled = true;
                resultEl.textContent = `Connect fehlgeschlagen: ${err.message}`;
                setStatus(`Fehler: ${err.message}`, true);
            }
        }

        async function sendEvent() {
            try {
                if (!ndk || !signer) throw new Error("Nicht verbunden.");
                sendBtn.disabled = true;
                connectBtn.disabled = true;
                resultEl.textContent = "Starte Senden...";

                setStatus("Prüfe RPC-Relays...");
                await ensureRpcRelaysConnected(signer, 6000, 1);

                const event = new NDKEvent(ndk, {
                    kind: 1,
                    created_at: Math.floor(Date.now() / 1000),
                    content: contentEl.value,
                    tags: []
                });

                resultEl.textContent = "Warte auf Signatur-Freigabe im Signer-Tab...";
                await withTimeout(event.sign(signer), 20000, "sign_event");

                resultEl.textContent = "Signiert, publiziere auf Relays...";
                const relaySet = buildFixedRelaySet(ndk, activeRelayUrls);
                const publishedTo = await withTimeout(
                    event.publish(relaySet, 8000, 1),
                    15000,
                    "publish"
                );

                resultEl.textContent =
                    `Gesendet.\n` +
                    `id: ${event.id}\n` +
                    `an Relays: ${Array.from(publishedTo).map((r) => r.url).join(", ") || "(unbekannt)"}`;
            } catch (err) {
                console.error(err);
                resultEl.textContent = `Fehler beim Senden: ${err.message}`;
            } finally {
                sendBtn.disabled = false;
                connectBtn.disabled = false;
            }
        }

        connectBtn.addEventListener("click", connectSigner);
        sendBtn.addEventListener("click", sendEvent);
        wpEnsureKeyBtn.addEventListener("click", ensureWpKeyForUser);
        signerUrlInput.addEventListener("change", refreshSignerFrame);
        syncIframeBtn.addEventListener("click", async () => {
            try {
                const info = await requestConnectionInfoFromIframe();
                applyConnectionInfo(info);
                setStatus("Connection URI aus iframe übernommen.");
            } catch (err) {
                setStatus(`Bridge-Fehler: ${err.message}`, true);
            }
        });
        embedSignerInput.addEventListener("change", () => {
            if (embedSignerInput.checked) {
                refreshSignerFrame();
                signerFrame.style.display = "block";
            } else {
                signerFrame.src = "about:blank";
                signerFrame.style.display = "none";
            }
        });
        signerFrame.addEventListener("load", async () => {
            if (!embedSignerInput.checked) return;
            try {
                signerFrame.contentWindow?.postMessage(
                    { source: BRIDGE_SOURCE, type: "request-frame-size" },
                    signerFrameOrigin
                );
            } catch (_err) {
                // ignore if iframe not yet ready
            }
            try {
                const info = await requestConnectionInfoFromIframe(1500);
                applyConnectionInfo(info);
            } catch (_err) {
                // optional sync; ignore if iframe not ready yet
            }
        });

        window.addEventListener("message", bridgeMessageHandler);
        refreshSignerFrame();
        hydrateUriFromLocalSigner();
    </script>
</body>
</html>
