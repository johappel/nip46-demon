<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPV Nostr Client (NIP-7 mit NIP-46 Fallback)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0 auto;
            padding: 20px;
            max-width: 920px;
            background: #121212;
            color: #fff;
        }
        .card {
            background: #1d1d1d;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
        }
        .label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
        }
        input, textarea, button {
            width: 100%;
            box-sizing: border-box;
            border-radius: 8px;
            border: 1px solid #444;
            background: #0f0f0f;
            color: #fff;
            padding: 10px;
            margin-bottom: 10px;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            border: none;
            background: #2a7fff;
            font-weight: 700;
            cursor: pointer;
        }
        button[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
        }
        .hint {
            color: #bbb;
            margin-top: 0;
        }
        .ok { color: #7ee787; }
        .err { color: #ff7b72; }
        .inline {
            width: auto;
            margin-right: 8px;
            transform: translateY(1px);
        }
        #signer-frame {
            width: 100%;
            height: 260px;
            border: 1px solid #333;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>MPV Nostr Client</h1>
    <p class="hint">NIP-7 API nach außen, intern optional NIP-46.</p>

    <div class="card">
        <label>
            <input id="prefer-native" class="inline" type="checkbox" checked>
            Natives NIP-7 bevorzugen (wenn vorhanden)
        </label>

        <label class="label" for="signer-url">Signer URL (iframe)</label>
        <input id="signer-url" value="./signer.html">

        <label>
            <input id="embed-signer" class="inline" type="checkbox" checked>
            Signer eingebettet starten
        </label>

        <button id="sync-iframe-btn">Connection URI aus iframe holen</button>
        <iframe id="signer-frame" title="Signer" src="./signer.html"></iframe>
    </div>

    <div class="card">
        <label class="label" for="conn-uri">Connection URI (nostrconnect:// oder bunker://)</label>
        <input id="conn-uri" placeholder="nostrconnect://<pubkey>?relay=wss%3A%2F%2F...">
        <button id="install-btn">NIP-7 Provider initialisieren</button>
        <div id="status">Noch nicht initialisiert</div>
        <pre id="user"></pre>
    </div>

    <div class="card">
        <h3>NIP-7 Client Test</h3>
        <label class="label" for="content">Event Content (kind:1)</label>
        <textarea id="content">Hallo aus mpv-nostr-client.html</textarea>
        <button id="pubkey-btn" disabled>window.nostr.getPublicKey()</button>
        <button id="send-btn" disabled>window.nostr.signEvent() + Publish</button>
        <pre id="result"></pre>
    </div>

    <script type="module">
        import NDK, { NDKEvent, NDKNip46Signer, NDKRelaySet } from "https://esm.sh/@nostr-dev-kit/ndk@3.0.0?bundle&target=es2022";

        const BRIDGE_SOURCE = "nip46-signer-bridge";
        const DEFAULT_RELAYS = [
            "wss://relay.damus.io",
            "wss://nos.lol",
            "wss://relay.primal.net",
            "wss://relay.snort.social"
        ];

        const preferNativeInput = document.getElementById("prefer-native");
        const signerUrlInput = document.getElementById("signer-url");
        const embedSignerInput = document.getElementById("embed-signer");
        const syncIframeBtn = document.getElementById("sync-iframe-btn");
        const signerFrame = document.getElementById("signer-frame");
        const connInput = document.getElementById("conn-uri");
        const installBtn = document.getElementById("install-btn");
        const pubkeyBtn = document.getElementById("pubkey-btn");
        const sendBtn = document.getElementById("send-btn");
        const statusEl = document.getElementById("status");
        const userEl = document.getElementById("user");
        const resultEl = document.getElementById("result");
        const contentEl = document.getElementById("content");

        let signerFrameOrigin = null;
        let lastBridgeConnectionInfo = null;
        let activeNdk = null;
        let activeRelayUrls = [];
        let nostrProvider = null;
        let cachedPubkey = "";

        function looksLikeNip7Provider(candidate) {
            return !!candidate &&
                typeof candidate.getPublicKey === "function" &&
                typeof candidate.signEvent === "function";
        }

        function setProviderReady(provider) {
            nostrProvider = provider;
            pubkeyBtn.disabled = false;
            sendBtn.disabled = false;
        }

        function adoptNativeProviderIfAvailable() {
            if (!preferNativeInput.checked) return false;
            if (!looksLikeNip7Provider(window.nostr)) return false;
            setProviderReady(window.nostr);
            setStatus("Natives NIP-7 erkannt. Bereit.");
            if (!userEl.textContent) {
                userEl.textContent = "Modus: NIP-7 (native)\nProvider erkannt.";
            }
            return true;
        }

        function setStatus(text, isError = false) {
            statusEl.textContent = text;
            statusEl.className = isError ? "err" : "ok";
        }

        function canonicalRelayUrl(url) {
            try {
                return new URL(url).toString().replace(/\/$/, "");
            } catch (_err) {
                return String(url || "");
            }
        }

        function uniqueRelayUrls(relays) {
            const map = new Map();
            for (const relay of relays || []) {
                const key = canonicalRelayUrl(relay);
                if (!key) continue;
                if (!map.has(key)) map.set(key, relay);
            }
            return Array.from(map.values());
        }

        function relayUrlsFromUri(uri) {
            const url = new URL(uri);
            const relays = url.searchParams.getAll("relay");
            return uniqueRelayUrls([...relays, ...DEFAULT_RELAYS]);
        }

        function toBunkerUri(uri, relays = []) {
            const url = new URL(uri);

            if (url.protocol === "bunker:") {
                const pubkey = url.hostname || url.pathname.replace(/^\/+/, "");
                const out = new URLSearchParams(url.searchParams);
                const mergedRelays = new Set([...out.getAll("relay"), ...relays]);
                out.delete("relay");
                for (const relay of mergedRelays) out.append("relay", relay);
                const qs = out.toString();
                return `bunker://${pubkey}${qs ? `?${qs}` : ""}`;
            }

            if (url.protocol !== "nostrconnect:") {
                throw new Error("URI muss mit nostrconnect:// oder bunker:// beginnen.");
            }

            const pubkey = url.hostname || url.pathname.replace(/^\/+/, "");
            if (!pubkey) throw new Error("Kein Pubkey in URI gefunden.");

            const out = new URLSearchParams();
            const mergedRelays = new Set([...url.searchParams.getAll("relay"), ...relays]);
            for (const relay of mergedRelays) out.append("relay", relay);

            const secret = url.searchParams.get("secret");
            if (secret) out.set("secret", secret);

            const qs = out.toString();
            return `bunker://${pubkey}${qs ? `?${qs}` : ""}`;
        }

        function buildSignerFrameSrc(rawUrl) {
            const signerUrl = new URL(rawUrl, window.location.href);
            signerUrl.searchParams.set("parentOrigin", window.location.origin);
            return signerUrl;
        }

        function refreshSignerFrame() {
            try {
                const signerUrl = buildSignerFrameSrc(signerUrlInput.value.trim() || "./signer.html");
                signerFrameOrigin = signerUrl.origin;
                signerFrame.src = signerUrl.toString();
                signerFrame.style.display = embedSignerInput.checked ? "block" : "none";
            } catch (err) {
                setStatus(`Ungültige Signer-URL: ${err.message}`, true);
            }
        }

        function applyConnectionInfo(info) {
            if (!info) return;
            if (typeof info.nostrconnectUri === "string" && info.nostrconnectUri.startsWith("nostrconnect://")) {
                connInput.value = info.nostrconnectUri;
            }
            lastBridgeConnectionInfo = info;
        }

        function requestConnectionInfoFromIframe(timeoutMs = 3000) {
            return new Promise((resolve, reject) => {
                if (!embedSignerInput.checked || !signerFrame.contentWindow) {
                    reject(new Error("Signer-iframe nicht aktiv."));
                    return;
                }
                if (!signerFrameOrigin) {
                    reject(new Error("Signer-Origin unbekannt."));
                    return;
                }

                const timeout = setTimeout(() => {
                    window.removeEventListener("message", onMessage);
                    reject(new Error("Keine Bridge-Antwort vom Signer-iframe."));
                }, timeoutMs);

                function onMessage(event) {
                    if (event.origin !== signerFrameOrigin) return;
                    const data = event.data;
                    if (!data || data.source !== BRIDGE_SOURCE) return;
                    if (data.type !== "ready" && data.type !== "connection-info" && data.type !== "locked") return;

                    clearTimeout(timeout);
                    window.removeEventListener("message", onMessage);

                    if (data.type === "locked") {
                        reject(new Error(data.payload?.reason || "Signer ist gesperrt."));
                        return;
                    }

                    resolve(data.payload);
                }

                window.addEventListener("message", onMessage);
                signerFrame.contentWindow.postMessage(
                    { source: BRIDGE_SOURCE, type: "get-connection-info" },
                    signerFrameOrigin
                );
            });
        }

        function bridgeMessageHandler(event) {
            if (!signerFrameOrigin || event.origin !== signerFrameOrigin) return;
            const data = event.data;
            if (!data || data.source !== BRIDGE_SOURCE) return;
            if (data.type !== "ready" && data.type !== "connection-info" && data.type !== "locked") return;

            if (data.type === "locked") {
                setStatus(`Signer gesperrt: ${data.payload?.reason || "Bitte entsperren."}`, true);
                return;
            }

            applyConnectionInfo(data.payload);
            setStatus("Signer bereit (Bridge).");
        }

        function withTimeout(promise, ms, stepName) {
            let timer;
            const timeoutPromise = new Promise((_, reject) => {
                timer = setTimeout(() => reject(new Error(`${stepName} Timeout nach ${ms}ms`)), ms);
            });
            return Promise.race([promise, timeoutPromise]).finally(() => clearTimeout(timer));
        }

        function buildFixedRelaySet(ndkInstance, relays) {
            const relayObjs = uniqueRelayUrls(relays)
                .map((url) => ndkInstance.pool.getRelay(url, true, false))
                .filter(Boolean);
            return new NDKRelaySet(new Set(relayObjs), ndkInstance, ndkInstance.pool);
        }

        async function ensurePublishContextForProvider() {
            if (activeNdk && activeRelayUrls.length > 0) return;

            let relays = [];

            const rawUri = connInput.value.trim();
            if (rawUri) {
                try {
                    relays = relayUrlsFromUri(rawUri);
                } catch (_err) {
                    // ignore and fallback
                }
            }

            if (relays.length === 0) relays = DEFAULT_RELAYS;
            relays = uniqueRelayUrls(relays);

            const ndk = new NDK({ explicitRelayUrls: relays });
            await withTimeout(ndk.connect(), 10000, "relay connect (publish context)");
            activeNdk = ndk;
            activeRelayUrls = relays;
        }

        function makeNip7Adapter({ ndk, signer, user, relays }) {
            const pubkey = user.pubkey;

            async function signEventLikeNip7(unsignedEvent) {
                const normalized = {
                    ...unsignedEvent,
                    pubkey,
                    tags: Array.isArray(unsignedEvent?.tags) ? unsignedEvent.tags : [],
                    created_at: unsignedEvent?.created_at || Math.floor(Date.now() / 1000)
                };

                const event = new NDKEvent(ndk, normalized);
                await withTimeout(event.sign(signer), 20000, "sign_event");

                const raw = typeof event.rawEvent === "function" ? event.rawEvent() : null;
                if (raw) return raw;

                return {
                    kind: event.kind,
                    content: event.content,
                    tags: event.tags || [],
                    created_at: event.created_at,
                    pubkey: event.pubkey,
                    id: event.id,
                    sig: event.sig
                };
            }

            async function nip04Encrypt(pubkeyTarget, plaintext) {
                if (signer?.nip04?.encrypt) return signer.nip04.encrypt(pubkeyTarget, plaintext);
                if (typeof signer?.nip04Encrypt === "function") return signer.nip04Encrypt(pubkeyTarget, plaintext);
                throw new Error("nip04.encrypt nicht verfuegbar.");
            }

            async function nip04Decrypt(pubkeyTarget, ciphertext) {
                if (signer?.nip04?.decrypt) return signer.nip04.decrypt(pubkeyTarget, ciphertext);
                if (typeof signer?.nip04Decrypt === "function") return signer.nip04Decrypt(pubkeyTarget, ciphertext);
                throw new Error("nip04.decrypt nicht verfuegbar.");
            }

            async function nip44Encrypt(pubkeyTarget, plaintext) {
                if (signer?.nip44?.encrypt) return signer.nip44.encrypt(pubkeyTarget, plaintext);
                if (typeof signer?.nip44Encrypt === "function") return signer.nip44Encrypt(pubkeyTarget, plaintext);
                throw new Error("nip44.encrypt nicht verfuegbar.");
            }

            async function nip44Decrypt(pubkeyTarget, ciphertext) {
                if (signer?.nip44?.decrypt) return signer.nip44.decrypt(pubkeyTarget, ciphertext);
                if (typeof signer?.nip44Decrypt === "function") return signer.nip44Decrypt(pubkeyTarget, ciphertext);
                throw new Error("nip44.decrypt nicht verfuegbar.");
            }

            return {
                getPublicKey: async () => pubkey,
                signEvent: signEventLikeNip7,
                getRelays: async () =>
                    Object.fromEntries(relays.map((url) => [url, { read: true, write: true }])),
                nip04: {
                    encrypt: nip04Encrypt,
                    decrypt: nip04Decrypt
                },
                nip44: {
                    encrypt: nip44Encrypt,
                    decrypt: nip44Decrypt
                }
            };
        }

        async function connectViaNip46() {
            let bridgeInfo = null;
            if (embedSignerInput.checked) {
                bridgeInfo = await requestConnectionInfoFromIframe().catch(() => null);
                if (bridgeInfo) applyConnectionInfo(bridgeInfo);
            }

            let relays;
            let bunkerUri;

            if (bridgeInfo?.bunkerUri && Array.isArray(bridgeInfo?.relays) && bridgeInfo.relays.length > 0) {
                relays = uniqueRelayUrls(bridgeInfo.relays);
                bunkerUri = bridgeInfo.bunkerUri;
            } else if (lastBridgeConnectionInfo?.bunkerUri && Array.isArray(lastBridgeConnectionInfo?.relays) && lastBridgeConnectionInfo.relays.length > 0) {
                relays = uniqueRelayUrls(lastBridgeConnectionInfo.relays);
                bunkerUri = lastBridgeConnectionInfo.bunkerUri;
            } else {
                const rawUri = connInput.value.trim();
                if (!rawUri) throw new Error("Bitte Connection URI eingeben oder aus iframe holen.");
                relays = uniqueRelayUrls(relayUrlsFromUri(rawUri));
                bunkerUri = toBunkerUri(rawUri, relays);
            }

            const ndk = new NDK({ explicitRelayUrls: relays });
            await withTimeout(ndk.connect(), 10000, "relay connect");

            const signer = NDKNip46Signer.bunker(ndk, bunkerUri);

            let user;
            try {
                user = await withTimeout(signer.blockUntilReady(), 12000, "nip46 handshake");
            } catch (_err) {
                const pubkey = await withTimeout(signer.getPublicKey(), 8000, "get_public_key");
                user = ndk.getUser({ pubkey });
            }

            activeNdk = ndk;
            activeRelayUrls = relays;

            return {
                provider: makeNip7Adapter({ ndk, signer, user, relays }),
                user,
                relays
            };
        }

        async function installProvider() {
            setStatus("Initialisiere Provider...");
            resultEl.textContent = "";

            if (preferNativeInput.checked && looksLikeNip7Provider(window.nostr)) {
                setProviderReady(window.nostr);
                setStatus("Natives NIP-7 wird genutzt.");
                userEl.textContent = "Modus: NIP-7 (native)\npubkey: (nicht abgefragt)";
                try {
                    await ensurePublishContextForProvider();
                } catch (_err) {
                    // publish context is optional here; signing still works
                }
                return;
            }

            const connected = await connectViaNip46();
            setProviderReady(connected.provider);

            if (!window.nostr || !preferNativeInput.checked) {
                window.nostr = nostrProvider;
            }

            setStatus("NIP-46 verbunden, NIP-7 Adapter aktiv.");
            userEl.textContent =
                `Modus: NIP-46 -> NIP-7 Adapter\n` +
                `pubkey: ${connected.user.pubkey}\n` +
                `npub: ${connected.user.npub}\n` +
                `relays: ${connected.relays.join(", ")}`;
        }

        async function callGetPublicKey() {
            if (!nostrProvider) throw new Error("Provider nicht initialisiert.");
            const pubkey = await withTimeout(nostrProvider.getPublicKey(), 20000, "window.nostr.getPublicKey");
            cachedPubkey = pubkey;
            if (userEl.textContent.startsWith("Modus: NIP-7 (native)")) {
                userEl.textContent = `Modus: NIP-7 (native)\npubkey: ${pubkey}`;
            }
            resultEl.textContent = `window.nostr.getPublicKey() => ${pubkey}`;
        }

        async function signAndPublishKind1() {
            if (!nostrProvider) throw new Error("Provider nicht initialisiert.");
            const unsignedEvent = {
                kind: 1,
                created_at: Math.floor(Date.now() / 1000),
                tags: [],
                content: contentEl.value
            };
            if (cachedPubkey) unsignedEvent.pubkey = cachedPubkey;

            resultEl.textContent = "Signiere via window.nostr.signEvent()...";
            const signedEvent = await withTimeout(
                nostrProvider.signEvent(unsignedEvent),
                25000,
                "window.nostr.signEvent"
            );
            resultEl.textContent = `Signiert:\n${JSON.stringify(signedEvent, null, 2)}`;

            await ensurePublishContextForProvider();
            const ndkEvent = new NDKEvent(activeNdk, signedEvent);
            const relaySet = buildFixedRelaySet(activeNdk, activeRelayUrls);
            const publishedTo = await withTimeout(ndkEvent.publish(relaySet, 8000, 1), 15000, "publish");
            resultEl.textContent +=
                `\n\nPubliziert an:\n${Array.from(publishedTo).map((r) => r.url).join("\n") || "(unbekannt)"}`;
        }

        installBtn.addEventListener("click", async () => {
            try {
                installBtn.disabled = true;
                await installProvider();
            } catch (err) {
                setStatus(`Fehler: ${err.message}`, true);
                resultEl.textContent = `Initialisierung fehlgeschlagen: ${err.message}`;
            } finally {
                installBtn.disabled = false;
            }
        });

        pubkeyBtn.addEventListener("click", async () => {
            try {
                await callGetPublicKey();
            } catch (err) {
                resultEl.textContent = `Fehler: ${err.message}`;
            }
        });

        sendBtn.addEventListener("click", async () => {
            try {
                sendBtn.disabled = true;
                installBtn.disabled = true;
                await signAndPublishKind1();
            } catch (err) {
                const msg = String(err?.message || err);
                if (msg.includes("window.nostr.signEvent Timeout")) {
                    resultEl.textContent =
                        `Fehler: ${msg}\n` +
                        "Hinweis: Bitte Signatur im Extension-Popup bestaetigen. " +
                        "Wenn bestaetigt wurde und trotzdem Timeout kommt, blockiert die Extension die Antwort.";
                } else {
                    resultEl.textContent = `Fehler: ${msg}`;
                }
            } finally {
                sendBtn.disabled = false;
                installBtn.disabled = false;
            }
        });

        signerUrlInput.addEventListener("change", refreshSignerFrame);
        embedSignerInput.addEventListener("change", () => {
            if (embedSignerInput.checked) {
                refreshSignerFrame();
            } else {
                signerFrame.src = "about:blank";
                signerFrame.style.display = "none";
            }
        });

        syncIframeBtn.addEventListener("click", async () => {
            try {
                const info = await requestConnectionInfoFromIframe();
                applyConnectionInfo(info);
                setStatus("Connection URI aus iframe übernommen.");
            } catch (err) {
                setStatus(`Bridge-Fehler: ${err.message}`, true);
            }
        });

        signerFrame.addEventListener("load", async () => {
            if (!embedSignerInput.checked) return;
            try {
                const info = await requestConnectionInfoFromIframe(1500);
                applyConnectionInfo(info);
            } catch (_err) {
                // optional sync
            }
        });

        window.addEventListener("message", bridgeMessageHandler);
        refreshSignerFrame();

        // Wenn bereits ein NIP-7 Provider vorhanden ist, direkt nutzbar machen.
        adoptNativeProviderIfAvailable();

        // Viele Extensions injizieren asynchron.
        window.addEventListener("nostr:ready", adoptNativeProviderIfAvailable);
        let nativeProbeCount = 0;
        const nativeProbe = setInterval(() => {
            nativeProbeCount++;
            if (adoptNativeProviderIfAvailable() || nativeProbeCount > 20) {
                clearInterval(nativeProbe);
            }
        }, 250);
    </script>
</body>
</html>
