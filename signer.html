<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Nostr Signer (No-Popup)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 10px;
            background: #121212;
            color: white;
            font-size: 14px;
        }
        #app-title {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 700;
        }
        #status {
            margin: 0 0 4px 0;
            font-weight: 700;
        }
        #user-info {
            margin: 0;
            color: #9ad1ff;
            white-space: pre-wrap;
        }
        #tab-nav {
            display: flex;
            gap: 6px;
            margin: 10px 0;
        }
        .tab-btn {
            margin: 0;
            padding: 8px 10px;
            background: #242424;
            color: #fff;
            border: 1px solid #343434;
        }
        .tab-btn.active {
            background: #2f7cfe;
            border-color: #2f7cfe;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        #tab-signer {
            padding: 10px;
            background: #171717;
            border: 1px solid #333;
            border-radius: 8px;
        }
        #connection-info {
            margin-top: 0;
            padding: 12px;
            background: #171717;
            border: 1px solid #333;
            border-radius: 8px;
            white-space: pre-wrap;
            overflow: auto;
            max-height: 180px;
        }
        #unlock-panel, #key-manager {
            margin-top: 10px;
            padding: 12px;
            background: #171717;
            border: 1px solid #333;
            border-radius: 8px;
            display: none;
        }
        #unlock-panel input, #unlock-panel select, #key-manager input, #key-manager select {
            width: 100%;
            box-sizing: border-box;
            margin-top: 6px;
            margin-bottom: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #0f0f0f;
            color: #fff;
        }
        #unlock-panel p, #key-manager p { margin: 0 0 10px 0; color: #bbb; }
        #active-key-info { margin-bottom: 10px; color: #9ad1ff; white-space: pre-wrap; }
        #request-log {
            margin-top: 10px;
            padding: 10px;
            min-height: 100px;
            max-height: 220px;
            overflow: auto;
            background: #171717;
            border: 1px solid #333;
            border-radius: 8px;
            white-space: pre-wrap;
        }
        #auth-modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #222; padding: 20px; border: 1px solid #444; border-radius: 8px; z-index: 1000; max-width: 680px; width: 95%;
        }
        .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
        button { cursor: pointer; padding: 10px 14px; margin: 5px; border-radius: 5px; border: none; }
        .btn-approve { background: #28a745; color: white; }
        .btn-allow-temporary { background: #2f7cfe; color: white; }
        .btn-reject { background: #dc3545; color: white; }
        .button-row { display: flex; flex-wrap: wrap; margin-top: 10px; }
        #request-details { white-space: pre-wrap; max-height: 280px; overflow: auto; background: #171717; border: 1px solid #333; border-radius: 8px; padding: 10px; }
        body.compact-connected {
            padding: 6px;
        }
        body.compact-connected #app-title {
            font-size: 13px;
            margin-bottom: 2px;
        }
        body.compact-connected #tab-nav,
        body.compact-connected #tab-info,
        body.compact-connected #tab-management {
            display: none !important;
        }
        body.compact-connected #tab-signer {
            padding: 6px 0 0 0;
            border: none;
            background: transparent;
        }
        body.compact-connected #status {
            margin-bottom: 2px;
            font-size: 12px;
        }
        body.compact-connected #user-info {
            font-size: 12px;
            color: #bbb;
        }
        body.compact-connected #auth-modal {
            max-width: 420px;
            width: calc(100% - 12px);
            padding: 12px;
        }
        body.compact-connected #request-details {
            display: none;
        }
    </style>
</head>
<body>

    <div id="app-title">NIP-46 Signer</div>
    <div id="status">Verbinde mit Relay...</div>

    <div id="tab-nav">
        <button class="tab-btn active" id="tab-btn-signer" type="button">Signer</button>
        <button class="tab-btn" id="tab-btn-info" type="button">Info/Log</button>
        <button class="tab-btn" id="tab-btn-management" type="button">Verwaltung</button>
    </div>

    <section class="tab-panel active" id="tab-signer">
        <div id="user-info">Starte Signer...</div>
    </section>

    <section class="tab-panel" id="tab-info">
        <pre id="connection-info">Verbindungsinformationen folgen nach Entsperrung.</pre>
        <pre id="request-log"></pre>
    </section>

    <section class="tab-panel" id="tab-management">
        <div id="unlock-panel">
            <h3 id="unlock-title">Signer entsperren</h3>
            <p id="unlock-hint"></p>
            <div id="unlock-key-row">
                <label for="unlock-key-select">Gespeicherter Schlüssel</label>
                <select id="unlock-key-select"></select>
            </div>
            <div id="unlock-name-row">
                <label for="unlock-name-input">Schlüsselname (optional)</label>
                <input id="unlock-name-input" placeholder="z.B. Laptop, Test, Main" />
            </div>
            <div id="unlock-nsec-row">
                <label for="unlock-nsec-input">nsec</label>
                <input id="unlock-nsec-input" placeholder="nsec1..." />
            </div>
            <div id="unlock-generate-row" class="button-row">
                <button class="btn-allow-temporary" id="unlock-generate-btn" type="button">Neuen nsec generieren</button>
            </div>
            <div id="unlock-password-row">
                <label for="unlock-password-input">Passwort</label>
                <input id="unlock-password-input" type="password" placeholder="Passwort" />
            </div>
            <div id="unlock-password-confirm-row">
                <label for="unlock-password-confirm-input">Passwort wiederholen</label>
                <input id="unlock-password-confirm-input" type="password" placeholder="Passwort wiederholen" />
            </div>
            <div id="unlock-remember-row">
                <label for="unlock-remember-select">Entsperrt bleiben (optional)</label>
                <select id="unlock-remember-select">
                    <option value="none">Nein (bei Reload wieder sperren)</option>
                    <option value="session">Während dieser Browser-Session</option>
                    <option value="15m">15 Minuten</option>
                    <option value="1h">1 Stunde</option>
                </select>
            </div>
            <div class="button-row">
                <button class="btn-approve" id="unlock-submit-btn">Weiter</button>
                <button class="btn-reject" id="unlock-cancel-btn">Abbrechen</button>
            </div>
        </div>

        <div id="key-manager">
            <h3>Schlüsselverwaltung</h3>
            <div id="active-key-info"></div>
            <label for="saved-keys-select">Gespeicherte Schlüssel</label>
            <select id="saved-keys-select"></select>
            <div class="button-row">
                <button class="btn-allow-temporary" id="switch-key-btn">Zu Auswahl wechseln</button>
                <button class="btn-approve" id="download-key-btn">Aktiven Schlüssel herunterladen</button>
            </div>
            <label for="new-key-name-input">Neuer Schlüsselname (optional)</label>
            <input id="new-key-name-input" placeholder="z.B. Phone Backup" />
            <label for="new-key-nsec-input">nsec importieren oder generieren</label>
            <input id="new-key-nsec-input" placeholder="nsec1..." />
            <div class="button-row">
                <button class="btn-allow-temporary" id="generate-key-btn">Neuen Schlüssel generieren</button>
                <button class="btn-approve" id="save-key-btn">Schlüssel speichern</button>
            </div>
            <label for="change-password-current-input">Aktuelles Passwort</label>
            <input id="change-password-current-input" type="password" placeholder="Aktuelles Passwort" />
            <label for="change-password-new-input">Neues Passwort</label>
            <input id="change-password-new-input" type="password" placeholder="Neues Passwort (mind. 8 Zeichen)" />
            <label for="change-password-confirm-input">Neues Passwort wiederholen</label>
            <input id="change-password-confirm-input" type="password" placeholder="Neues Passwort wiederholen" />
            <div class="button-row">
                <button class="btn-approve" id="change-password-btn">Passwort ändern</button>
            </div>
        </div>
    </section>

    <div id="overlay" class="overlay"></div>
    <div id="auth-modal">
        <h3 id="request-title">Signier-Anfrage</h3>
        <p id="request-details"></p>
        <div class="button-row">
            <button class="btn-approve" id="allow-once-btn">Einmal erlauben</button>
            <button class="btn-allow-temporary" id="allow-always-btn">Immer erlauben</button>
            <button class="btn-reject" id="reject-btn">Ablehnen</button>
        </div>
    </div>

    <script type="module">
        import NDK, { NDKNip46Backend, NDKPrivateKeySigner } from "https://esm.sh/@nostr-dev-kit/ndk@3.0.0?bundle&target=es2022";

        // ===== Storage Keys =====
        // Älterer Speicherort für unverschlüsselte nsec (nur bei Migration relevant)
        const LEGACY_NSEC_STORAGE_KEY = "nip46_demo_nsec";
        // Verschlüsselte nsec im alten v1-Format (wird auf neues Keyring-Format migriert)
        const ENCRYPTED_NSEC_STORAGE_KEY = "nip46_demo_nsec_enc_v1";
        // Modernes Keyring-Format v2 - Array von verschlüsselten Einträgen mit IDs
        const KEYRING_STORAGE_KEY = "nip46_demo_keyring_enc_v2";
        // Speichert die ID des aktuell aktiven Schlüssels
        const ACTIVE_KEY_ID_STORAGE_KEY = "nip46_demo_active_key_id_v1";
        // Session-basiertes Entsperra-Caching (wird beim Browser-Reload gelöscht)
        const UNLOCK_CACHE_SESSION_KEY = "nip46_unlock_cache_session_v1";
        // TTL-basiertes Entsperra-Caching mit Ablaufzeit (15m/1h möglich)
        const UNLOCK_CACHE_TTL_KEY = "nip46_unlock_cache_ttl_v1";
        // Speichert Genehmigungen für Anfragen (pubkey:method -> TTL oder PERMISSION_FOREVER)
        const PERMISSION_STORAGE_KEY = "nip46_permissions_v1";
        // Bindet WordPress User-IDs an Nostr Schlüssel (für WP-Integration)
        const WP_USER_BINDINGS_STORAGE_KEY = "nip46_wp_user_bindings_v1";
        
        // ===== Relay und Bridge-Konfiguration =====
        // Standard-Relays für NIP-46 RPC-Kommunikation
        const RELAYS = [
            "wss://relay.damus.io",
            "wss://nos.lol",
            "wss://relay.primal.net",
            "wss://relay.snort.social"
        ];
        // Identifikator für sichere Cross-Origin PostMessage-Kommunikation mit Parent-Frame
        const BRIDGE_SOURCE = "nip46-signer-bridge";
        
        // ===== Kryptographische Konstanten =====
        // PBKDF2 Iterationen für Passwort-Hashing (210.000 = NIST empfohlen für 2024)
        const PBKDF2_ITERATIONS = 210000;
        // NIP-46 Methoden, die automatisch genehmigt werden (keine User-Bestätigung nötig)
        const AUTO_ALLOW_METHODS = new Set(["connect", "ping", "get_public_key"]);
        // NIP-46 Methoden, die Benutzer-Bestätigung benötigen (sensitiv)
        const SENSITIVE_METHODS = new Set([
            "sign_event",
            "nip04_encrypt",
            "nip04_decrypt",
            "nip44_encrypt",
            "nip44_decrypt"
        ]);
        // Spezialwert: Genehmigung läuft niemals ab (-1 = unbegrenzt)
        const PERMISSION_FOREVER = -1;
        // Bech32-Encoding Zeichensatz (für nsec1 Format)
        const BECH32_CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
        // Bech32 Generator-Polynome (für Checksum-Berechnung)
        const BECH32_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

        // ===== Global State =====
        // Queue für ausstehende Genehmigungsanfragen (FIFO-Verarbeitung)
        const pendingPermissionRequests = [];
        // Die aktuell zu bearbeitende Genehmigungsanfrage
        let activePermissionRequest = null;
        // Verbindungsinformationen (bunker URI, pubkey, relays, etc.) nach Entsperrrung
        let connectionInfo = null;
        // true wenn dieser iframe in einem Parent-Frame lädt (nicht top-level)
        const isEmbeddedContext = window.parent !== window;

        // ===== Signer Session State =====
        // Das aktuell gespeicherte Passwort (wird nach Entsperrrung in RAM gehalten)
        let sessionPassword = "";
        // Das gesamte Keyring-Objekt mit allen verschlüsselten Schlüsseln
        let currentKeyring = null;
        // Die ID des aktuell aktiven Schlüssels
        let activeKeyId = null;
        // Der entschlüsselte nsec des aktiven Schlüssels (SENSIBEL!)
        let activeNsec = null;
        // Das NDKUser-Objekt des aktiven Schlüssels (enthält pubkey, npub, etc.)
        let activeUser = null;
        // Letzte gemeldete Frame-Höhe (für iframe Auto-Resize)
        let lastPostedFrameHeight = 0;
        // Flag um redundante Frame-Size Updates zu vermeiden (Debouncing)
        let frameSizeNotifyScheduled = false;

        // ===== Validierungs- und Normalisierungs-Funktionen =====
        
        /**
         * Prüft, ob ein String ein gültiger nsec ist.
         * nsec muss mit "nsec1" beginnen und mindestens 21 Zeichen lang sein.
         * @param {string} nsec - Zu prüfender Wert
         * @returns {boolean} true wenn gültiger nsec
         */
        function isValidNsec(nsec) {
            return typeof nsec === "string" && nsec.startsWith("nsec1") && nsec.length > 20;
        }

        /**
         * Normalisiert einen Schlüsselnamen (trimmt Whitespace, gibt leeren String bei null zurück).
         * @param {string} name - Der zu normalisierende Name
         * @returns {string} Normalisierter Name (trimmed) oder leerer String
         */
        function normalizeKeyName(name) {
            return typeof name === "string" ? name.trim() : "";
        }

        /**
         * Erzeugt einen Anzeigetext für einen Schlüssel.
         * Nutzt den benutzerdefinierten Namen oder fällt auf "Schlüssel N" zurück.
         * @param {object} entry - Der Keyring-Eintrag mit optionalem name
         * @param {number} index - Der Index des Eintrags (für Fallback-Text)
         * @returns {string} Anzeigetext
         */
        function keyDisplayName(entry, index = 0) {
            const custom = normalizeKeyName(entry?.name);
            return custom || `Schlüssel ${index + 1}`;
        }

        /**
         * Konvertiert einen beliebigen Input in einen sicheren Dateinamen.
         * Löscht Sonderzeichen, konvertiert zu Kleinbuchstaben, limitiert auf a-z0-9_-
         * @param {string} input - Beliebiger Input-String
         * @returns {string} Sicherer Dateiname oder "nostr-key" als Fallback
         */
        function safeFilename(input) {
            const raw = String(input || "").toLowerCase();
            const slug = raw.replace(/[^a-z0-9_-]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
            return slug || "nostr-key";
        }

        // ===== Basis-Konvertierungen (Bytes, Base64) =====
        
        /**
         * Konvertiert ein Uint8Array in einen Base64-String.
         * Dies wird für Speicherung von binären Daten (salt, iv, ciphertext) verwendet.
         * @param {Uint8Array} bytes - Die zu kodierenden Bytes
         * @returns {string} Base64-kodierter String
         */
        function bytesToBase64(bytes) {
            let binary = "";
            for (const b of bytes) binary += String.fromCharCode(b);
            return btoa(binary);
        }

        /**
         * Konvertiert einen Base64-String zurück in Uint8Array.
         * Umkehroperation zu bytesToBase64.
         * @param {string} base64 - Der zu dekodierte Base64-String
         * @returns {Uint8Array} Die dekodierten Bytes
         */
        function base64ToBytes(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            return bytes;
        }

        // ===== AES-GCM Verschlüsselung (für nsec-Speicherung) =====
        
        /**
         * Leitet einen AES-256 Schlüssel aus einem Passwort ab.
         * Nutzt PBKDF2 (Password-Based Key Derivation Function) mit SHA-256.
         * 
         * Dies ist eine sichere Methode, um aus einem Benutzerpasswort einen starken Verschlüsslungsschlüssel zu generieren.
         * Ohne PBKDF2 wäre das Passwort zu kurz für direkten AES-Einsatz.
         * 
         * @param {string} password - Das Benutzerpasswort
         * @param {Uint8Array} saltBytes - Ein eindeutiger Salt (pro Verschlüsselung neu generiert)
         * @param {number} iterations - PBKDF2 Iterationen (default: PBKDF2_ITERATIONS = 210000)
         * @returns {Promise<CryptoKey>} Ein WebCrypto AES-GCM Schlüssel
         */
        async function deriveAesKeyFromPassword(password, saltBytes, iterations = PBKDF2_ITERATIONS) {
            const enc = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                "PBKDF2",
                false,
                ["deriveKey"]
            );

            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: saltBytes,
                    iterations,
                    hash: "SHA-256"
                },
                passwordKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Verschlüssselt einen nsec mit AES-256-GCM.
         * Generiert zufällige salt und iv (Initialization Vector).
         * 
         * Produkt: Ein Object mit folgenden Feldern:
         * - v: Versionsnummer (aktuell 1)
         * - kdf: "PBKDF2-SHA256"
         * - alg: "AES-GCM"
         * - iter: Anzahl der PBKDF2-Iterationen
         * - salt: Base64-kodierter Salt
         * - iv: Base64-kodierter IV
         * - ct: Base64-kodierter Ciphertext (verschlüsselter nsec)
         * 
         * @param {string} nsec - Der zu verschlüsselnde nsec
         * @param {string} password - Das Benutzerpasswort
         * @returns {Promise<object>} Verschlüsslungs-Payload mit ct, salt, iv
         */
        async function encryptNsec(nsec, password) {
            const enc = new TextEncoder();
            // Zufällige salt und iv generieren (für Sicherheit)
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveAesKeyFromPassword(password, salt);
            const ciphertext = new Uint8Array(
                await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv },
                    key,
                    enc.encode(nsec)
                )
            );

            return {
                v: 1,
                kdf: "PBKDF2-SHA256",
                alg: "AES-GCM",
                iter: PBKDF2_ITERATIONS,
                salt: bytesToBase64(salt),
                iv: bytesToBase64(iv),
                ct: bytesToBase64(ciphertext)
            };
        }

        /**
         * Entschlüsselt einen zuvor mit encryptNsec verschlüsselten nsec.
         * Extrahiert salt, iv und ciphertext aus dem Payload und entschlüssselt mit dem Passwort.
         * 
         * @param {object} payload - Das Verschlüsselungs-Object (mit ct, salt, iv, kdf, alg, iter)
         * @param {string} password - Das Benutzerpasswort
         * @returns {Promise<string>} Der entschlüsselte nsec
         * @throws {Error} Wenn Format ungültig oder Passwort falsch ist
         */
        async function decryptNsec(payload, password) {
            if (!payload || payload.v !== 1 || !payload.salt || !payload.iv || !payload.ct) {
                throw new Error("Ungültiges verschlüsseltes Format.");
            }

            const dec = new TextDecoder();
            const salt = base64ToBytes(payload.salt);
            const iv = base64ToBytes(payload.iv);
            const ciphertext = base64ToBytes(payload.ct);
            const key = await deriveAesKeyFromPassword(password, salt, payload.iter || PBKDF2_ITERATIONS);
            const clear = await crypto.subtle.decrypt(
                { name: "AES-GCM", iv },
                key,
                ciphertext
            );

            return dec.decode(clear);
        }

        // ===== Bech32-Encoding (für nsec-Generierung) =====
        // Bech32 ist das Standard-Encoding für Nostr-Werte (nsec, npub, note, usw.)
        // Format: hrp1 + bech32-encoded-data + 6-stellige Checksumme
        
        /**
         * Berechnet das Bech32-Polynom (Checksummen-Algorithmus).
         * Dies wird verwendet um Bech32-Strings zu validieren und zu checksum-en.
         * 
         * @param {array} values - Array von 5-Bit-Werten
         * @returns {number} Das Polynom-Ergebnis
         */
        function bech32Polymod(values) {
            let chk = 1;
            for (const v of values) {
                const top = chk >> 25;
                chk = ((chk & 0x1ffffff) << 5) ^ v;
                for (let i = 0; i < 5; i++) {
                    if ((top >> i) & 1) chk ^= BECH32_GENERATORS[i];
                }
            }
            return chk;
        }

        /**
         * Expandiert das Human Readable Part (HRP) für Bech32-Checksumme.
         * Konvertiert HRP zu speziellem Format für Polynom-Berechnung.
         * 
         * @param {string} hrp - Das HRP (z.B. "nsec")
         * @returns {array} Expandiertes HRP als Array von 5-Bit-Werten
         */
        function bech32HrpExpand(hrp) {
            const out = [];
            for (let i = 0; i < hrp.length; i++) out.push(hrp.charCodeAt(i) >> 5);
            out.push(0);
            for (let i = 0; i < hrp.length; i++) out.push(hrp.charCodeAt(i) & 31);
            return out;
        }

        /**
         * Erstellt die 6-stellige Bech32-Checksumme für ein HRP und seine Daten.
         * 
         * @param {string} hrp - Das Human Readable Part (z.B. "nsec")
         * @param {array} data - Die 5-Bit-Daten zum Checksum-en
         * @returns {array} 6-stelliges Checksum als Array
         */
        function bech32CreateChecksum(hrp, data) {
            const values = [...bech32HrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0];
            const polymod = bech32Polymod(values) ^ 1;
            const out = [];
            for (let p = 0; p < 6; p++) {
                out.push((polymod >> (5 * (5 - p))) & 31);
            }
            return out;
        }

        /**
         * Kodiert Daten in Bech32-Format mit HRP und Checksumme.
         * Dies wird verwendet um nsec1... oder npub1... Strings zu generieren.
         * 
         * @param {string} hrp - Das Human Readable Part ("nsec" oder "npub")
         * @param {array} data - Die 5-Bit-Daten zum Kodieren
         * @returns {string} Der fertig kodierte Bech32-String (z.B. "nsec1...")
         */
        function bech32Encode(hrp, data) {
            const combined = [...data, ...bech32CreateChecksum(hrp, data)];
            let encoded = `${hrp}1`;
            for (const d of combined) encoded += BECH32_CHARSET[d];
            return encoded;
        }

        /**
         * Konvertiert Bits zwischen verschiedenen Breiten.
         * Wird von Bech32-Encoding verwendet um 8-Bit Bytes zu 5-Bit Werten zu konvertieren.
         * 
         * @param {array} data - Die zu konvertierenden Daten
         * @param {number} fromBits - Quell-Bit-Breite (normalerweise 8)
         * @param {number} toBits - Ziel-Bit-Breite (normalerweise 5)
         * @param {boolean} pad - true um mit Nullen zu padden wenn nötig
         * @returns {array} Die konvertierten Daten
         * @throws {Error} Bei ungültigen Eingabe-Werten oder Padding-Problemen
         */
        function convertBits(data, fromBits, toBits, pad = true) {
            let acc = 0;
            let bits = 0;
            const out = [];
            const maxv = (1 << toBits) - 1;
            const maxAcc = (1 << (fromBits + toBits - 1)) - 1;

            for (const value of data) {
                if (value < 0 || (value >> fromBits) !== 0) throw new Error("Ungültige Bit-Konvertierung.");
                acc = ((acc << fromBits) | value) & maxAcc;
                bits += fromBits;
                while (bits >= toBits) {
                    bits -= toBits;
                    out.push((acc >> bits) & maxv);
                }
            }

            if (pad) {
                if (bits > 0) out.push((acc << (toBits - bits)) & maxv);
            } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv) !== 0) {
                throw new Error("Ungültiges Padding in Bit-Konvertierung.");
            }

            return out;
        }

        /**
         * Generiert einen random nsec (geheime Schlüssel-Darstellung).
         * 
         * Prozess:
         * 1. 32 zufällige Bytes generieren (256 Bits)
         * 2. In 5-Bit-Format konvertieren (für Bech32)
         * 3. Mit "nsec" HRP in Bech32-Format enkodieren
         * 
         * @returns {string} Ein neuer randomisierter nsec1... String
         */
        function generateRandomNsec() {
            const secret = crypto.getRandomValues(new Uint8Array(32));
            const words = convertBits(secret, 8, 5, true);
            return bech32Encode("nsec", words);
        }

        function generateKeyId() {
            return `key_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
        }

        function loadKeyring() {
            try {
                const raw = localStorage.getItem(KEYRING_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || parsed.v !== 1 || !Array.isArray(parsed.keys)) return null;
                const keys = parsed.keys
                    .filter((entry) => entry && typeof entry.id === "string" && entry.id && entry.payload && typeof entry.payload === "object")
                    .map((entry) => ({
                        id: entry.id,
                        name: normalizeKeyName(entry.name),
                        createdAt: typeof entry.createdAt === "number" ? entry.createdAt : Date.now(),
                        payload: entry.payload
                    }));
                if (keys.length === 0) return null;
                return { v: 1, keys };
            } catch (_err) {
                return null;
            }
        }

        function saveKeyring(keyring) {
            localStorage.setItem(KEYRING_STORAGE_KEY, JSON.stringify(keyring));
        }

        function activeKeyIdFromStorage() {
            return localStorage.getItem(ACTIVE_KEY_ID_STORAGE_KEY);
        }

        function setActiveKeyId(id) {
            localStorage.setItem(ACTIVE_KEY_ID_STORAGE_KEY, id);
        }

        // ===== WordPress User ID Bindings =====
        // Ermöglicht es, WordPress User-IDs an spezifische Nostr-Schlüssel zu binden
        // (nützlich für WordPress Integrations mit Nostr-Authentifizierung)
        
        /**
         * Normalisiert eine WordPress User-ID und führt Validierung durch.
         * 
         * @param {string} userId - Die zu normalisierende WP User-ID
         * @returns {string} Die normalisierte User-ID (trimmed)
         * @throws {Error} Wenn userId leer oder zu lang ist
         */
        function normalizeWpUserId(userId) {
            const normalized = String(userId ?? "").trim();
            if (!normalized) throw new Error("userId fehlt.");
            if (normalized.length > 128) throw new Error("userId ist zu lang (max. 128 Zeichen).");
            return normalized;
        }

        /**
         * Erzeugt ein Label für einen WP User-Binding aus der User-ID.
         * Nutzt nur sichere Zeichen (lowercase, a-z0-9._-)
         * 
         * @param {string|number} userId - Die WordPress User-ID
         * @returns {string} Ein Label wie "WP admin" oder "WP user-123"
         */
        function wpBindingLabelForUser(userId) {
            const compact = String(userId)
                .toLowerCase()
                .replace(/[^a-z0-9._-]+/g, "-")
                .replace(/-+/g, "-")
                .replace(/^-|-$/g, "");
            return compact ? `WP ${compact}` : "WP User Key";
        }

        /**
         * Lädt die WP User ID -> Nostr Key ID Bindings aus localStorage.
         * Format: { v: 1, byUserId: { "user1": "key_xyz", ... } }
         * 
         * @returns {object} Das Bindings-Objekt oder leerer Default
         */
        function loadWpUserBindings() {
            try {
                const raw = localStorage.getItem(WP_USER_BINDINGS_STORAGE_KEY);
                if (!raw) return { v: 1, byUserId: {} };
                const parsed = JSON.parse(raw);
                if (!parsed || parsed.v !== 1 || typeof parsed.byUserId !== "object" || parsed.byUserId === null) {
                    return { v: 1, byUserId: {} };
                }

                const sanitized = {};
                for (const [userId, keyId] of Object.entries(parsed.byUserId)) {
                    if (typeof userId === "string" && userId && typeof keyId === "string" && keyId) {
                        sanitized[userId] = keyId;
                    }
                }
                return { v: 1, byUserId: sanitized };
            } catch (_err) {
                return { v: 1, byUserId: {} };
            }
        }

        /**
         * Speichert die WP User ID -> Key ID Bindings im localStorage.
         * 
         * @param {object} bindings - Das zu speichernde Bindings-Objekt
         */
        function saveWpUserBindings(bindings) {
            localStorage.setItem(WP_USER_BINDINGS_STORAGE_KEY, JSON.stringify(bindings));
        }

        // ===== Unlock-Cache (Session und TTL-basiert) =====
        // Speichert das Passwort temporär um häufiges Eingeben zu vermeiden
        
        /**
         * Löscht den Unlock-Cache vollständig:
         * - Session-Cache aus sessionStorage
         * - TTL-Cache aus localStorage
         */
        function clearUnlockCache() {
            sessionStorage.removeItem(UNLOCK_CACHE_SESSION_KEY);
            localStorage.removeItem(UNLOCK_CACHE_TTL_KEY);
        }

        /**
         * Lädt den Unlock-Cache aus Session- oder localStorage.
         * Gibt Priorität dem Session-Cache (wird beim Tab-Schließen gelöscht).
         * Prüft TTL bei TTL-Cache und löscht abgelaufene Caches.
         * 
         * @returns {object|null} { mode: "session"|"ttl", password: str, keyId: str } oder null
         */
        function loadUnlockCache() {
            try {
                const sessionRaw = sessionStorage.getItem(UNLOCK_CACHE_SESSION_KEY);
                if (sessionRaw) {
                    const sessionParsed = JSON.parse(sessionRaw);
                    if (sessionParsed && typeof sessionParsed.password === "string") {
                        return {
                            mode: "session",
                            password: sessionParsed.password,
                            keyId: typeof sessionParsed.keyId === "string" ? sessionParsed.keyId : null
                        };
                    }
                    sessionStorage.removeItem(UNLOCK_CACHE_SESSION_KEY);
                }
            } catch (_err) {
                sessionStorage.removeItem(UNLOCK_CACHE_SESSION_KEY);
            }

            try {
                const ttlRaw = localStorage.getItem(UNLOCK_CACHE_TTL_KEY);
                if (!ttlRaw) return null;
                const ttlParsed = JSON.parse(ttlRaw);
                const now = Date.now();
                if (!ttlParsed || typeof ttlParsed.password !== "string" || typeof ttlParsed.expiresAt !== "number" || ttlParsed.expiresAt <= now) {
                    localStorage.removeItem(UNLOCK_CACHE_TTL_KEY);
                    return null;
                }
                return {
                    mode: "ttl",
                    password: ttlParsed.password,
                    keyId: typeof ttlParsed.keyId === "string" ? ttlParsed.keyId : null
                };
            } catch (_err) {
                localStorage.removeItem(UNLOCK_CACHE_TTL_KEY);
                return null;
            }
        }

        /**
         * Speichert das Unlock-Passwort temporär zur Vermeidung erneuter Eingaben.
         * 
         * Modes:
         * - "none": Keinen Cache speichern (löscht existierenden Cache)
         * - "session": Im sessionStorage (wird mit Tab-Schließen gelöscht)
         * - "15m": Im localStorage mit 15 Minuten TTL
         * - "1h": Im localStorage mit 1 Stunde TTL
         * 
         * @param {string} password - Das zu speichernde Passwort
         * @param {string} keyId - Die ID des zu speichernden Schlüssels (optional)
         * @param {string} mode - Der Speicher-Modus ("session", "15m", "1h", "none")
         */
        function saveUnlockCache(password, keyId, mode) {
            clearUnlockCache();
            if (!password || mode === "none") return;

            if (mode === "session") {
                sessionStorage.setItem(
                    UNLOCK_CACHE_SESSION_KEY,
                    JSON.stringify({ v: 1, keyId: keyId || null, password, savedAt: Date.now() })
                );
                return;
            }

            let ttlMs = 0;
            if (mode === "15m") ttlMs = 15 * 60 * 1000;
            if (mode === "1h") ttlMs = 60 * 60 * 1000;
            if (ttlMs <= 0) return;

            localStorage.setItem(
                UNLOCK_CACHE_TTL_KEY,
                JSON.stringify({
                    v: 1,
                    keyId: keyId || null,
                    password,
                    savedAt: Date.now(),
                    expiresAt: Date.now() + ttlMs
                })
            );
        }

        /**
         * Aktualisiert die Key-ID im Unlock-Cache ohne das Passwort zu ändern.
         * Nützlich wenn der Benutzer zwischen Schlüsseln wechselt.
         * 
         * @param {string} keyId - Die neue Key-ID
         */
        function updateUnlockCacheKeyId(keyId) {
            if (!keyId) return;

            try {
                const sessionRaw = sessionStorage.getItem(UNLOCK_CACHE_SESSION_KEY);
                if (sessionRaw) {
                    const parsed = JSON.parse(sessionRaw);
                    if (parsed && typeof parsed.password === "string") {
                        parsed.keyId = keyId;
                        sessionStorage.setItem(UNLOCK_CACHE_SESSION_KEY, JSON.stringify(parsed));
                    }
                }
            } catch (_err) {
                sessionStorage.removeItem(UNLOCK_CACHE_SESSION_KEY);
            }

            try {
                const ttlRaw = localStorage.getItem(UNLOCK_CACHE_TTL_KEY);
                if (ttlRaw) {
                    const parsed = JSON.parse(ttlRaw);
                    if (parsed && typeof parsed.password === "string" && typeof parsed.expiresAt === "number" && parsed.expiresAt > Date.now()) {
                        parsed.keyId = keyId;
                        localStorage.setItem(UNLOCK_CACHE_TTL_KEY, JSON.stringify(parsed));
                    }
                }
            } catch (_err) {
                localStorage.removeItem(UNLOCK_CACHE_TTL_KEY);
            }
        }

        // ===== Keyring-Verwaltung (Speicherung und Abruf) =====
        
        /**
         * Generiert eine eindeutige ID für einen neuen Keyring-Eintrag.
         * Format: key_<timestamp36>_<randomhex>
         * 
         * @returns {string} Die neue eindeutige Key-ID
         */
        function generateKeyId() {
            return `key_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
        }

        /**
         * Lädt das gesamte Keyring aus dem localStorage.
         * Das Keyring ist ein Array von verschlüsselten Schlüssel-Einträgen.
         * 
         * Format:
         * {
         *   v: 1,
         *   keys: [
         *     { id: "key_...", name: "...", createdAt: timestamp, payload: {...encrypted...} },
         *     ...
         *   ]
         * }
         * 
         * @returns {object|null} Das Keyring-Objekt oder null wenn nicht vorhanden/ungültig
         */
        function loadKeyring() {
            try {
                const raw = localStorage.getItem(KEYRING_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || parsed.v !== 1 || !Array.isArray(parsed.keys)) return null;
                const keys = parsed.keys
                    .filter((entry) => entry && typeof entry.id === "string" && entry.id && entry.payload && typeof entry.payload === "object")
                    .map((entry) => ({
                        id: entry.id,
                        name: normalizeKeyName(entry.name),
                        createdAt: typeof entry.createdAt === "number" ? entry.createdAt : Date.now(),
                        payload: entry.payload
                    }));
                if (keys.length === 0) return null;
                return { v: 1, keys };
            } catch (_err) {
                return null;
            }
        }

        /**
         * Speichert das gesamte Keyring im localStorage.
         * Das Keyring ist jetzt ein Array - jeder Schlüssel ist separat verschlüsselt.
         * 
         * @param {object} keyring - Das zu speichernde Keyring-Objekt mit keys-Array
         */
        function saveKeyring(keyring) {
            localStorage.setItem(KEYRING_STORAGE_KEY, JSON.stringify(keyring));
        }

        /**
         * Lädt die ID des aktuell aktiven Schlüssels aus dem Storage.
         * Diese ID wird verwendet um nach dem Reload den richtigen Schlüssel zu aktivieren.
         * 
         * @returns {string|null} Die aktive Key-ID oder null
         */
        function activeKeyIdFromStorage() {
            return localStorage.getItem(ACTIVE_KEY_ID_STORAGE_KEY);
        }

        /**
         * Speichert die ID des aktuell aktiven Schlüssels.
         * 
         * @param {string} id - Die zu speichernde Key-ID
         */
        function setActiveKeyId(id) {
            localStorage.setItem(ACTIVE_KEY_ID_STORAGE_KEY, id);
        }

        /**
         * Findet und gibt einen Keyring-Eintrag zurück, basierend auf bevorzugter oder Standard-Auswahl.
         * 
         * Priorität:
         * 1. Wenn preferredId vorhanden: Suche diesen Eintrag
         * 2. Fallback: Nutze den ersten (index 0) Eintrag
         * 
         * @param {object} keyring - Das Keyring-Objekt mit keys-Array
         * @param {string} preferredId - Bevorzugte Key-ID (optional)
         * @returns {object} { entry: Eintrag, index: Array-Index }
         */
        function resolveActiveKeyEntry(keyring, preferredId = null) {
            const wanted = preferredId || activeKeyIdFromStorage();
            if (wanted) {
                const idx = keyring.keys.findIndex((entry) => entry.id === wanted);
                if (idx >= 0) return { entry: keyring.keys[idx], index: idx };
            }
            return { entry: keyring.keys[0], index: 0 };
        }

        /**
         * Erstellt einen neuen Keyring-Eintrag durch Verschlüsselung des nsec.
         * 
         * @param {string} nsec - Der nsec zum Verschlüsseln
         * @param {string} password - Das Passwort zum Verschlüsseln
         * @param {string} name - Optionaler Name für diesen Schlüssel
         * @returns {Promise<object>} Ein neuer Keyring-Eintrag { id, name, createdAt, payload }
         */
        async function createKeyringEntry(nsec, password, name = "") {
            return {
                id: generateKeyId(),
                name: normalizeKeyName(name),
                createdAt: Date.now(),
                payload: await encryptNsec(nsec, password)
            };
        }

        async function ensureWpUserKey(userIdRaw) {
            if (!currentKeyring || !sessionPassword) {
                throw new Error("Signer ist gesperrt. Bitte zuerst entsperren.");
            }

            const userId = normalizeWpUserId(userIdRaw);
            const bindings = loadWpUserBindings();
            const boundKeyId = bindings.byUserId[userId];

            if (boundKeyId) {
                const existingIndex = currentKeyring.keys.findIndex((entry) => entry.id === boundKeyId);
                if (existingIndex >= 0) {
                    const existingEntry = currentKeyring.keys[existingIndex];
                    const existingNsec = await decryptNsec(existingEntry.payload, sessionPassword);
                    if (!isValidNsec(existingNsec)) {
                        throw new Error("Gebundener Schlüssel ist ungültig.");
                    }
                    const existingUser = await new NDKPrivateKeySigner(existingNsec).user();
                    appendRequestLog(`WP-Binding gefunden: ${userId} -> ${keyDisplayName(existingEntry, existingIndex)}`);
                    return {
                        userId,
                        keyId: existingEntry.id,
                        keyName: keyDisplayName(existingEntry, existingIndex),
                        pubkey: existingUser.pubkey,
                        npub: existingUser.npub,
                        existed: true,
                        active: existingEntry.id === activeKeyId
                    };
                }
                delete bindings.byUserId[userId];
            }

            const nsec = generateRandomNsec();
            const newEntry = await createKeyringEntry(nsec, sessionPassword, wpBindingLabelForUser(userId));
            currentKeyring.keys.push(newEntry);
            saveKeyring(currentKeyring);

            bindings.byUserId[userId] = newEntry.id;
            saveWpUserBindings(bindings);

            const createdUser = await new NDKPrivateKeySigner(nsec).user();
            appendRequestLog(`WP-Binding erstellt: ${userId} -> ${keyDisplayName(newEntry, currentKeyring.keys.length - 1)}`);
            renderKeyManager();
            return {
                userId,
                keyId: newEntry.id,
                keyName: keyDisplayName(newEntry, currentKeyring.keys.length - 1),
                pubkey: createdUser.pubkey,
                npub: createdUser.npub,
                existed: false,
                active: newEntry.id === activeKeyId
            };
        }

        async function getOrAskActiveKey() {
            if (!crypto?.subtle) {
                throw new Error("WebCrypto nicht verfügbar. Nutze HTTPS oder localhost.");
            }

            const keyring = loadKeyring();
            if (keyring) {
                const { entry: defaultEntry } = resolveActiveKeyEntry(keyring);
                const cachedUnlock = loadUnlockCache();
                if (cachedUnlock?.password) {
                    const { entry: cachedEntry, index: cachedIndex } = resolveActiveKeyEntry(keyring, cachedUnlock.keyId || defaultEntry.id);
                    try {
                        const cachedNsec = await decryptNsec(cachedEntry.payload, cachedUnlock.password);
                        if (!isValidNsec(cachedNsec)) throw new Error("invalid cached nsec");
                        setActiveKeyId(cachedEntry.id);
                        appendRequestLog(`Auto-Entsperrt (${cachedUnlock.mode === "session" ? "Session" : "TTL"}): ${keyDisplayName(cachedEntry, cachedIndex)}`);
                        return {
                            nsec: cachedNsec,
                            password: cachedUnlock.password,
                            keyId: cachedEntry.id,
                            keyName: keyDisplayName(cachedEntry, cachedIndex),
                            keyring
                        };
                    } catch (_err) {
                        clearUnlockCache();
                        appendRequestLog("Gespeicherte Entsperrung war ungueltig und wurde entfernt.");
                    }
                }
                postBridgeMessage("locked", { reason: "Passwort benötigt." });
                const unlock = await showUnlockPanel({
                    title: "Signer entsperren",
                    hint: "Bitte Passwort eingeben und optional gespeicherten Schlüssel wählen.",
                    askNsec: false,
                    askConfirm: false,
                    askName: false,
                    askKey: true,
                    askRemember: true,
                    defaultRememberMode: "none",
                    keyOptions: keyring.keys.map((entry, index) => ({
                        id: entry.id,
                        label: keyDisplayName(entry, index)
                    })),
                    defaultKeyId: defaultEntry.id,
                    submitLabel: "Entsperren"
                });
                if (!unlock.password) throw new Error("Kein Passwort angegeben.");

                const { entry: selectedEntry, index: selectedIndex } = resolveActiveKeyEntry(keyring, unlock.keyId || defaultEntry.id);
                try {
                    const nsec = await decryptNsec(selectedEntry.payload, unlock.password);
                    if (!isValidNsec(nsec)) throw new Error("Ungültiger nsec nach Entschlüsselung.");
                    setActiveKeyId(selectedEntry.id);
                    saveUnlockCache(unlock.password, selectedEntry.id, unlock.rememberMode || "none");
                    return {
                        nsec,
                        password: unlock.password,
                        keyId: selectedEntry.id,
                        keyName: keyDisplayName(selectedEntry, selectedIndex),
                        keyring
                    };
                } catch (_err) {
                    throw new Error("Entsperren fehlgeschlagen. Passwort oder Daten sind ungültig.");
                }
            }

            const encryptedRaw = localStorage.getItem(ENCRYPTED_NSEC_STORAGE_KEY);
            if (encryptedRaw) {
                postBridgeMessage("locked", { reason: "Migration auf Keyring." });
                const unlock = await showUnlockPanel({
                    title: "Signer entsperren (Migration)",
                    hint: "Bitte Passwort eingeben, um den bisherigen Schlüssel ins neue Keyring-Format zu migrieren.",
                    askNsec: false,
                    askConfirm: false,
                    askName: false,
                    askKey: false,
                    askRemember: true,
                    defaultRememberMode: "none",
                    submitLabel: "Entsperren & migrieren"
                });
                if (!unlock.password) throw new Error("Kein Passwort angegeben.");

                try {
                    const payload = JSON.parse(encryptedRaw);
                    const nsec = await decryptNsec(payload, unlock.password);
                    if (!isValidNsec(nsec)) throw new Error("Ungültiger nsec nach Entschlüsselung.");
                    const firstEntry = await createKeyringEntry(nsec, unlock.password, "Migrated Key");
                    const migratedKeyring = { v: 1, keys: [firstEntry] };
                    saveKeyring(migratedKeyring);
                    setActiveKeyId(firstEntry.id);
                    saveUnlockCache(unlock.password, firstEntry.id, unlock.rememberMode || "none");
                    localStorage.removeItem(ENCRYPTED_NSEC_STORAGE_KEY);
                    localStorage.removeItem(LEGACY_NSEC_STORAGE_KEY);
                    appendRequestLog("Migration: alter verschlüsselter Storage wurde ins Keyring-Format übernommen.");
                    return {
                        nsec,
                        password: unlock.password,
                        keyId: firstEntry.id,
                        keyName: keyDisplayName(firstEntry, 0),
                        keyring: migratedKeyring
                    };
                } catch (_err) {
                    throw new Error("Migration fehlgeschlagen. Passwort oder Alt-Daten sind ungültig.");
                }
            }

            const legacy = localStorage.getItem(LEGACY_NSEC_STORAGE_KEY);
            if (isValidNsec(legacy)) {
                postBridgeMessage("locked", { reason: "Migration von Klartext-nsec auf verschlüsselten Keyring." });
                const unlock = await showUnlockPanel({
                    title: "Signer absichern",
                    hint: "Klartext-nsec gefunden. Bitte Passwort setzen und optional Schlüssel benennen.",
                    askNsec: false,
                    askConfirm: true,
                    askName: true,
                    askKey: false,
                    askRemember: true,
                    defaultRememberMode: "none",
                    submitLabel: "Migrieren"
                });
                if (!unlock.password) throw new Error("Kein Passwort angegeben.");
                if (unlock.password.length < 8) throw new Error("Passwort muss mindestens 8 Zeichen haben.");
                if (unlock.password !== unlock.passwordConfirm) throw new Error("Passwörter stimmen nicht überein.");

                const firstEntry = await createKeyringEntry(legacy, unlock.password, unlock.keyName);
                const migratedKeyring = { v: 1, keys: [firstEntry] };
                saveKeyring(migratedKeyring);
                setActiveKeyId(firstEntry.id);
                saveUnlockCache(unlock.password, firstEntry.id, unlock.rememberMode || "none");
                localStorage.removeItem(ENCRYPTED_NSEC_STORAGE_KEY);
                localStorage.removeItem(LEGACY_NSEC_STORAGE_KEY);
                appendRequestLog("Klartext-nsec wurde in verschlüsselten Keyring migriert.");
                return {
                    nsec: legacy,
                    password: unlock.password,
                    keyId: firstEntry.id,
                    keyName: keyDisplayName(firstEntry, 0),
                    keyring: migratedKeyring
                };
            }

            postBridgeMessage("locked", { reason: "Ersteinrichtung erforderlich." });
            const setup = await showUnlockPanel({
                title: "Signer einrichten",
                hint: "Bitte nsec eingeben oder generieren, Passwort setzen und optional einen Namen vergeben.",
                askNsec: true,
                askConfirm: true,
                askName: true,
                askKey: false,
                askRemember: true,
                defaultRememberMode: "none",
                allowGenerate: true,
                submitLabel: "Speichern & entsperren"
            });
            if (!setup.nsec) throw new Error("Kein nsec angegeben.");
            if (!isValidNsec(setup.nsec)) {
                throw new Error("Ungültiger nsec. Erwartet wird ein kompletter nsec1...-Wert.");
            }
            if (!setup.password) throw new Error("Kein Passwort angegeben.");
            if (setup.password.length < 8) throw new Error("Passwort muss mindestens 8 Zeichen haben.");
            if (setup.password !== setup.passwordConfirm) throw new Error("Passwörter stimmen nicht überein.");

            const firstEntry = await createKeyringEntry(setup.nsec, setup.password, setup.keyName);
            const newKeyring = { v: 1, keys: [firstEntry] };
            saveKeyring(newKeyring);
            setActiveKeyId(firstEntry.id);
            saveUnlockCache(setup.password, firstEntry.id, setup.rememberMode || "none");
            localStorage.removeItem(ENCRYPTED_NSEC_STORAGE_KEY);
            localStorage.removeItem(LEGACY_NSEC_STORAGE_KEY);
            appendRequestLog("nsec verschlüsselt im Keyring gespeichert.");
            return {
                nsec: setup.nsec,
                password: setup.password,
                keyId: firstEntry.id,
                keyName: keyDisplayName(firstEntry, 0),
                keyring: newKeyring
            };
        }

        function formatRequestParams(request) {
            const params = request?.params;
            if (!params) return "(keine)";

            try {
                if (request.method === "sign_event" && typeof params.rawEvent === "function") {
                    return JSON.stringify(params.rawEvent(), null, 2);
                }

                if (typeof params === "string") return params;
                return JSON.stringify(params, null, 2);
            } catch (_err) {
                return "[Parameter konnten nicht serialisiert werden]";
            }
        }

        function appendRequestLog(line) {
            const logEl = document.getElementById("request-log");
            const now = new Date().toLocaleTimeString();
            const previous = logEl.innerText ? `${logEl.innerText}\n` : "";
            const combined = `[${now}] ${line}\n${previous}`.split("\n").slice(0, 60).join("\n");
            logEl.innerText = combined.trimEnd();
            scheduleFrameSizeNotification();
        }

        function intrinsicBodyContentHeight() {
            const body = document.body;
            if (!body) return 0;

            const bodyTop = body.getBoundingClientRect().top;
            let maxBottom = 0;
            for (const child of body.children) {
                const style = window.getComputedStyle(child);
                if (style.display === "none") continue;
                if (style.position === "fixed") continue;
                const rect = child.getBoundingClientRect();
                if (!Number.isFinite(rect.bottom) || !Number.isFinite(rect.top)) continue;
                const bottom = rect.bottom - bodyTop;
                maxBottom = Math.max(maxBottom, bottom);
            }
            return Math.max(0, Math.ceil(maxBottom));
        }

        function computeDocumentHeight() {
            const body = document.body;
            const intrinsic = intrinsicBodyContentHeight();

            if (intrinsic > 0) return intrinsic + 2;

            return Math.max(
                body?.scrollHeight || 0,
                body?.offsetHeight || 0
            );
        }

        function notifyParentFrameSize(force = false) {
            const height = Math.max(110, computeDocumentHeight());
            if (!force && Math.abs(height - lastPostedFrameHeight) < 4) return;
            lastPostedFrameHeight = height;
            postBridgeMessage("frame-size", { height });
        }

        function scheduleFrameSizeNotification(force = false) {
            if (force) {
                frameSizeNotifyScheduled = false;
                notifyParentFrameSize(true);
                return;
            }
            if (frameSizeNotifyScheduled) return;
            frameSizeNotifyScheduled = true;
            requestAnimationFrame(() => {
                frameSizeNotifyScheduled = false;
                notifyParentFrameSize(false);
            });
        }

        function setupFrameAutoResizeBridge() {
            const resizeTarget = document.documentElement;

            if (typeof ResizeObserver === "function") {
                const ro = new ResizeObserver(() => scheduleFrameSizeNotification(false));
                ro.observe(resizeTarget);
                if (document.body) ro.observe(document.body);
            }

            window.addEventListener("resize", () => scheduleFrameSizeNotification(false));
            scheduleFrameSizeNotification(true);
        }

        function setActiveTab(tabName) {
            const tabs = ["signer", "info", "management"];
            for (const tab of tabs) {
                const panel = document.getElementById(`tab-${tab}`);
                const btn = document.getElementById(`tab-btn-${tab}`);
                if (panel) panel.classList.toggle("active", tab === tabName);
                if (btn) btn.classList.toggle("active", tab === tabName);
            }
            scheduleFrameSizeNotification(false);
        }

        function setupTabNavigation() {
            const signerBtn = document.getElementById("tab-btn-signer");
            const infoBtn = document.getElementById("tab-btn-info");
            const managementBtn = document.getElementById("tab-btn-management");

            signerBtn.addEventListener("click", () => setActiveTab("signer"));
            infoBtn.addEventListener("click", () => setActiveTab("info"));
            managementBtn.addEventListener("click", () => setActiveTab("management"));
        }

        function setCompactConnectedMode(enabled) {
            document.body.classList.toggle("compact-connected", Boolean(enabled));
            scheduleFrameSizeNotification(true);
        }

        function showUnlockPanel(options) {
            const panel = document.getElementById("unlock-panel");
            const titleEl = document.getElementById("unlock-title");
            const hintEl = document.getElementById("unlock-hint");
            const keyRow = document.getElementById("unlock-key-row");
            const nameRow = document.getElementById("unlock-name-row");
            const nsecRow = document.getElementById("unlock-nsec-row");
            const generateRow = document.getElementById("unlock-generate-row");
            const confirmRow = document.getElementById("unlock-password-confirm-row");
            const rememberRow = document.getElementById("unlock-remember-row");
            const keySelect = document.getElementById("unlock-key-select");
            const nameInput = document.getElementById("unlock-name-input");
            const nsecInput = document.getElementById("unlock-nsec-input");
            const passwordInput = document.getElementById("unlock-password-input");
            const confirmInput = document.getElementById("unlock-password-confirm-input");
            const rememberSelect = document.getElementById("unlock-remember-select");
            const generateBtn = document.getElementById("unlock-generate-btn");
            const submitBtn = document.getElementById("unlock-submit-btn");
            const cancelBtn = document.getElementById("unlock-cancel-btn");

            titleEl.innerText = options.title;
            hintEl.innerText = options.hint || "";
            submitBtn.innerText = options.submitLabel || "Weiter";

            keyRow.style.display = options.askKey ? "block" : "none";
            nameRow.style.display = options.askName ? "block" : "none";
            nsecRow.style.display = options.askNsec ? "block" : "none";
            generateRow.style.display = options.askNsec && options.allowGenerate ? "flex" : "none";
            confirmRow.style.display = options.askConfirm ? "block" : "none";
            rememberRow.style.display = options.askRemember ? "block" : "none";

            keySelect.innerHTML = "";
            if (Array.isArray(options.keyOptions)) {
                for (const option of options.keyOptions) {
                    const opt = document.createElement("option");
                    opt.value = option.id;
                    opt.textContent = option.label;
                    keySelect.appendChild(opt);
                }
            }
            if (options.defaultKeyId) keySelect.value = options.defaultKeyId;

            nameInput.value = options.defaultName || "";
            nsecInput.value = options.defaultNsec || "";
            nsecInput.readOnly = Boolean(options.readonlyNsec);
            passwordInput.value = "";
            confirmInput.value = "";
            rememberSelect.value = options.defaultRememberMode || "none";

            setActiveTab("management");
            panel.style.display = "block";
            scheduleFrameSizeNotification(true);

            return new Promise((resolve, reject) => {
                const cleanup = () => {
                    submitBtn.onclick = null;
                    cancelBtn.onclick = null;
                    generateBtn.onclick = null;
                    panel.style.display = "none";
                    scheduleFrameSizeNotification(true);
                };

                submitBtn.onclick = () => {
                    const value = {
                        keyId: keySelect.value,
                        keyName: nameInput.value.trim(),
                        nsec: nsecInput.value.trim(),
                        password: passwordInput.value,
                        passwordConfirm: confirmInput.value,
                        rememberMode: rememberSelect.value || "none"
                    };
                    cleanup();
                    resolve(value);
                };

                cancelBtn.onclick = () => {
                    cleanup();
                    reject(new Error("Entsperren abgebrochen."));
                };

                generateBtn.onclick = () => {
                    try {
                        nsecInput.value = generateRandomNsec();
                    } catch (err) {
                        appendRequestLog(`Generieren fehlgeschlagen: ${err.message}`);
                    }
                };
            });
        }

        function renderKeyManager() {
            const panel = document.getElementById("key-manager");
            if (!currentKeyring || !Array.isArray(currentKeyring.keys) || currentKeyring.keys.length === 0) {
                panel.style.display = "none";
                scheduleFrameSizeNotification(false);
                return;
            }

            const select = document.getElementById("saved-keys-select");
            const activeInfoEl = document.getElementById("active-key-info");
            select.innerHTML = "";

            currentKeyring.keys.forEach((entry, index) => {
                const option = document.createElement("option");
                option.value = entry.id;
                option.textContent = keyDisplayName(entry, index);
                if (entry.id === activeKeyId) option.selected = true;
                select.appendChild(option);
            });

            const { entry: activeEntry, index: activeIndex } = resolveActiveKeyEntry(currentKeyring, activeKeyId);
            const currentName = keyDisplayName(activeEntry, activeIndex);
            const npubShort = activeUser?.npub ? `${activeUser.npub.slice(0, 16)}...` : "(noch nicht geladen)";
            activeInfoEl.innerText = `Aktiv: ${currentName}\nnpub: ${npubShort}`;

            panel.style.display = "block";
            scheduleFrameSizeNotification(false);
        }

        async function switchToSelectedKey() {
            if (!currentKeyring || !Array.isArray(currentKeyring.keys) || currentKeyring.keys.length === 0) {
                throw new Error("Kein Keyring geladen.");
            }
            const selectedId = document.getElementById("saved-keys-select").value;
            if (!selectedId) throw new Error("Kein Schlüssel ausgewählt.");
            if (selectedId === activeKeyId) {
                appendRequestLog("Ausgewählter Schlüssel ist bereits aktiv.");
                return;
            }

            setActiveKeyId(selectedId);
            updateUnlockCacheKeyId(selectedId);
            appendRequestLog("Aktiver Schlüssel gewechselt. Seite wird neu geladen.");
            window.location.reload();
        }

        async function downloadActiveKeyPair() {
            if (!currentKeyring || !sessionPassword) throw new Error("Keyring ist nicht entsperrt.");
            const { entry: activeEntry, index: activeIndex } = resolveActiveKeyEntry(currentKeyring, activeKeyId);
            if (!activeEntry) throw new Error("Kein aktiver Schlüssel gefunden.");

            const nsec = await decryptNsec(activeEntry.payload, sessionPassword);
            const signer = new NDKPrivateKeySigner(nsec);
            const user = await signer.user();
            const displayName = keyDisplayName(activeEntry, activeIndex);
            const exportPayload = {
                label: displayName,
                createdAt: new Date(activeEntry.createdAt || Date.now()).toISOString(),
                nsec,
                pubkey: user.pubkey,
                npub: user.npub
            };

            const blob = new Blob([JSON.stringify(exportPayload, null, 2)], { type: "application/json" });
            const fileName = `${safeFilename(displayName)}-${safeFilename(user.npub.slice(0, 12))}.json`;
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
            appendRequestLog(`Schlüsselpaar exportiert: ${fileName}`);
        }

        async function saveAdditionalKey() {
            if (!currentKeyring || !sessionPassword) throw new Error("Keyring ist nicht entsperrt.");

            const nameInput = document.getElementById("new-key-name-input");
            const nsecInput = document.getElementById("new-key-nsec-input");
            const nsec = nsecInput.value.trim();
            const name = normalizeKeyName(nameInput.value);

            if (!nsec) throw new Error("Bitte nsec eingeben oder generieren.");
            if (!isValidNsec(nsec)) throw new Error("Ungültiger nsec. Erwartet nsec1...");

            const newSigner = new NDKPrivateKeySigner(nsec);
            const newUser = await newSigner.user();

            for (const entry of currentKeyring.keys) {
                try {
                    const existingNsec = await decryptNsec(entry.payload, sessionPassword);
                    const existingUser = await new NDKPrivateKeySigner(existingNsec).user();
                    if (existingUser.pubkey === newUser.pubkey) {
                        throw new Error("Dieser Schlüssel ist bereits gespeichert.");
                    }
                } catch (err) {
                    if (err.message === "Dieser Schlüssel ist bereits gespeichert.") throw err;
                }
            }

            const entry = await createKeyringEntry(nsec, sessionPassword, name);
            currentKeyring.keys.push(entry);
            saveKeyring(currentKeyring);
            appendRequestLog(`Neuer Schlüssel gespeichert: ${keyDisplayName(entry, currentKeyring.keys.length - 1)}`);
            nsecInput.value = "";
            renderKeyManager();
        }

        async function changeKeyringPassword() {
            if (!currentKeyring || !sessionPassword) throw new Error("Keyring ist nicht entsperrt.");

            const currentInput = document.getElementById("change-password-current-input");
            const newInput = document.getElementById("change-password-new-input");
            const confirmInput = document.getElementById("change-password-confirm-input");

            const currentPassword = currentInput.value;
            const newPassword = newInput.value;
            const newPasswordConfirm = confirmInput.value;

            if (!currentPassword) throw new Error("Bitte aktuelles Passwort eingeben.");
            if (currentPassword !== sessionPassword) throw new Error("Aktuelles Passwort ist falsch.");
            if (!newPassword) throw new Error("Bitte neues Passwort eingeben.");
            if (newPassword.length < 8) throw new Error("Neues Passwort muss mindestens 8 Zeichen haben.");
            if (newPassword !== newPasswordConfirm) throw new Error("Neue Passwörter stimmen nicht überein.");
            if (newPassword === sessionPassword) throw new Error("Neues Passwort muss sich vom aktuellen unterscheiden.");

            const reencryptedKeys = [];
            for (const entry of currentKeyring.keys) {
                const nsec = await decryptNsec(entry.payload, sessionPassword);
                const reencryptedPayload = await encryptNsec(nsec, newPassword);
                reencryptedKeys.push({
                    ...entry,
                    payload: reencryptedPayload
                });
            }

            currentKeyring = {
                ...currentKeyring,
                keys: reencryptedKeys
            };
            saveKeyring(currentKeyring);

            sessionPassword = newPassword;
            saveUnlockCache(newPassword, activeKeyId, "session");

            currentInput.value = "";
            newInput.value = "";
            confirmInput.value = "";
            appendRequestLog("Passwort geändert. Alle gespeicherten Schlüssel wurden neu verschlüsselt.");
        }

        function setupKeyManagerHandlers() {
            document.getElementById("switch-key-btn").addEventListener("click", async () => {
                try {
                    await switchToSelectedKey();
                } catch (err) {
                    appendRequestLog(`Switch fehlgeschlagen: ${err.message}`);
                }
            });

            document.getElementById("download-key-btn").addEventListener("click", async () => {
                try {
                    await downloadActiveKeyPair();
                } catch (err) {
                    appendRequestLog(`Download fehlgeschlagen: ${err.message}`);
                }
            });

            document.getElementById("generate-key-btn").addEventListener("click", () => {
                try {
                    const generated = generateRandomNsec();
                    document.getElementById("new-key-nsec-input").value = generated;
                    appendRequestLog("Neuer nsec wurde generiert.");
                } catch (err) {
                    appendRequestLog(`Generieren fehlgeschlagen: ${err.message}`);
                }
            });

            document.getElementById("save-key-btn").addEventListener("click", async () => {
                try {
                    await saveAdditionalKey();
                } catch (err) {
                    appendRequestLog(`Speichern fehlgeschlagen: ${err.message}`);
                }
            });

            document.getElementById("change-password-btn").addEventListener("click", async () => {
                try {
                    await changeKeyringPassword();
                } catch (err) {
                    appendRequestLog(`Passwort ändern fehlgeschlagen: ${err.message}`);
                }
            });
        }

        // ===== Bridge-Kommunikation (PostMessage Protocol mit Parent) =====
        // Der Bridge Layer ermöglicht sichere Kommunikation zwischen parent window und signer iframe
        // über PostMessage, mit Validierung von Origin und Source
        
        /**
         * Ermittelt die erwartete Origin des Parent-Frames.
         * Dies wird zur Validierung von PostMessage-Events verwendet.
         * 
         * Priorität:
         * 1. Query-Parameter ?parentOrigin=... (explizit gesetzt)
         * 2. document.referrer (Browser liest automatisch)
         * 3. null (unbekannt/nicht gesetzt)
         * 
         * @returns {string|null} Die Origin des Parent-Frames (z.B. "https://example.com") oder null
         */
        function expectedParentOrigin() {
            const params = new URLSearchParams(window.location.search);
            const fromQuery = params.get("parentOrigin");
            if (fromQuery) return fromQuery;

            if (document.referrer) {
                try {
                    return new URL(document.referrer).origin;
                } catch (_err) {
                    return null;
                }
            }

            return null;
        }

        /**
         * Sendet eine Nachricht an den Parent-Frame über PostMessage Bridge mit Origin-Check.
         * 
         * Nachrichten-Format:
         * { source: "nip46-signer-bridge", type: string, payload: object }
         * 
         * Verwendete Message-Types:
         * - "ready": Signer hat erfolgreich initialisiert (payload: connectionInfo)
         * - "locked": Signer benötigt Entsperrrung (payload: { reason: string })
         * - "connection-info": Response auf connection-info Anfrage
         * - "frame-size": Meldet aktuelle iframe Höhe (payload: { height: number })
         * - "wp-user-key-result": Response auf wp-ensure-user-key Anfrage
         * 
         * @param {string} type - Der Nachrichtentyp
         * @param {object} payload - Die Nachricht-Daten
         */
        function postBridgeMessage(type, payload) {
            if (window.parent === window) return;

            const targetOrigin = expectedParentOrigin();
            if (!targetOrigin) {
                appendRequestLog(`Bridge blockiert: unbekannter parentOrigin (${type})`);
                return;
            }

            try {
                window.parent.postMessage(
                    { source: BRIDGE_SOURCE, type, payload },
                    targetOrigin
                );
            } catch (err) {
                appendRequestLog(`Bridge-Post fehlgeschlagen: ${err.message}`);
            }
        }

        /**
         * Verarbeitet eingehende PostMessage-Events vom Parent-Frame.
         * Validiert Origin und Source vor der Verarbeitung.
         * 
         * Unterstützte Anfragen:
         * - "ping": Prüfe ob Signer ready ist → antworte mit connectionInfo oder "locked"
         * - "get-connection-info": Wie ping
         * - "request-frame-size": Parent fragt nach neuer Höhe → antworte mit frame-size
         * - "wp-ensure-user-key": {userId} → erstelle/lade WP User Key → antworte mit wp-user-key-result
         * 
         * @param {MessageEvent} event - Das PostMessage-Event vom Parent-Frame
         */
        function bridgeMessageHandler(event) {
            const targetOrigin = expectedParentOrigin();
            if (!targetOrigin || event.origin !== targetOrigin) return;

            const data = event.data;
            if (!data || data.source !== BRIDGE_SOURCE) return;

            if (data.type === "request-frame-size") {
                scheduleFrameSizeNotification(true);
                return;
            }

            if (data.type === "ping" || data.type === "get-connection-info") {
                if (connectionInfo) {
                    postBridgeMessage("connection-info", connectionInfo);
                } else {
                    postBridgeMessage("locked", { reason: "Signer ist noch gesperrt." });
                }
                return;
            }

            if (data.type === "wp-ensure-user-key") {
                const requestId = typeof data?.payload?.requestId === "string" ? data.payload.requestId : "";
                const userId = data?.payload?.userId;
                (async () => {
                    try {
                        const ensured = await ensureWpUserKey(userId);
                        postBridgeMessage("wp-user-key-result", {
                            requestId,
                            ok: true,
                            ...ensured
                        });
                    } catch (err) {
                        postBridgeMessage("wp-user-key-result", {
                            requestId,
                            ok: false,
                            error: err?.message || "WP-Key konnte nicht bereitgestellt werden."
                        });
                    }
                })();
            }
        }

        // ===== Permissions-System (Genehmigung für NIP-46 Methoden) =====
        // Kontrolliert welche Remote-Signaturen durch welche Clients genehmigt sind
        // Unterstützt sowohl Single-Use (einmalig) als auch TTL-basierte (zeitlich begrenzt) Genehmigungen
        
        /**
         * Lädt die Genehmigungen aus dem localStorage.
         * Format: { "pubkey:method": expiryTimestamp | PERMISSION_FOREVER, ... }
         * 
         * @returns {object} Die geladenen Genehmigungen (oder {} wenn keine vorhanden)
         */
        function loadPermissions() {
            try {
                const raw = localStorage.getItem(PERMISSION_STORAGE_KEY);
                return raw ? JSON.parse(raw) : {};
            } catch (_err) {
                return {};
            }
        }

        /**
         * Speichert die Genehmigungen im localStorage.
         * 
         * @param {object} permissions - Die zu speichernden Genehmigungen
         */
        function savePermissions(permissions) {
            localStorage.setItem(PERMISSION_STORAGE_KEY, JSON.stringify(permissions));
        }

        /**
         * Erzeugt einen eindeutigen Key für eine Genehmigung.
         * Format: "<pubkey>:<method>" (z.B. "abc123....:sign_event")
         * 
         * @param {string} pubkey - Der öffentliche Schlüssel des Clients
         * @param {string} method - Die NIP-46 Methodenname
         * @returns {string} Der Genehmigungskey
         */
        function permissionKey(pubkey, method) {
            return `${pubkey}:${method}`;
        }

        /**
         * Entfernt abgelaufene Genehmigungen aus dem Storage.
         * Behält nur Genehmigungen die noch nicht expired sind oder ewig gültig (PERMISSION_FOREVER).
         * 
         * @returns {object} Die bereinigten Genehmigungen
         */
        function clearExpiredPermissions() {
            const now = Date.now();
            const permissions = loadPermissions();
            let changed = false;

            for (const [key, value] of Object.entries(permissions)) {
                if (value === PERMISSION_FOREVER) continue;
                if (typeof value !== "number" || value <= now) {
                    delete permissions[key];
                    changed = true;
                }
            }

            if (changed) savePermissions(permissions);
            return permissions;
        }

        /**
         * Prüft ob eine Genehmigung für eine Client-Methode-Kombination aktiv ist.
         * Entfernt zuerst abgelaufene Genehmigungen.
         * 
         * @param {string} pubkey - Der Client-Pubkey
         * @param {string} method - Die Methodenname
         * @returns {boolean} true wenn aktiv genehmigt, sonst false
         */
        function hasActivePermission(pubkey, method) {
            const permissions = clearExpiredPermissions();
            const key = permissionKey(pubkey, method);
            const value = permissions[key];
            return value === PERMISSION_FOREVER || (typeof value === "number" && value > Date.now());
        }

        /**
         * Gewährt eine zeitlich begrenzte Genehmigung (TTL - Time To Live).
         * Diese läuft nach ttlMs Millisekunden ab.
         * 
         * @param {string} pubkey - Der Client-Pubkey
         * @param {string} method - Die Methodenname
         * @param {number} ttlMs - Millisekunden bis zur Ablauf
         */
        function grantPermission(pubkey, method, ttlMs) {
            const permissions = clearExpiredPermissions();
            permissions[permissionKey(pubkey, method)] = Date.now() + ttlMs;
            savePermissions(permissions);
        }

        /**
         * Gewährt eine unbegrenzte Genehmigung (läuft nie ab).
         * Diese Genehmigung ist permanent bis manuell gelöscht.
         * 
         * @param {string} pubkey - Der Client-Pubkey
         * @param {string} method - Die Methodenname
         */
        function grantPermissionForever(pubkey, method) {
            const permissions = clearExpiredPermissions();
            permissions[permissionKey(pubkey, method)] = PERMISSION_FOREVER;
            savePermissions(permissions);
        }

        /**
         * Verarbeitet die Warteschlange ausstehender Genehmigungsanfragen sequenziell.
         * Zeigt Modal für jede Anfrage an und wartet auf Benutzer-Entscheidung.
         */
        function processPermissionQueue() {
            if (activePermissionRequest || pendingPermissionRequests.length === 0) return;

            activePermissionRequest = pendingPermissionRequests.shift();
            const { request, resolve } = activePermissionRequest;
            const method = request?.method;
            const pubkey = request?.pubkey;

            showModal(
                request,
                () => {
                    appendRequestLog(`Erlaubt (einmal): ${method}`);
                    resolve(true);
                    activePermissionRequest = null;
                    processPermissionQueue();
                },
                () => {
                    if (pubkey && method) {
                        grantPermissionForever(pubkey, method);
                    }
                    appendRequestLog(`Erlaubt (immer): ${method}`);
                    resolve(true);
                    activePermissionRequest = null;
                    processPermissionQueue();
                },
                () => {
                    appendRequestLog(`Abgelehnt: ${method}`);
                    resolve(false);
                    activePermissionRequest = null;
                    processPermissionQueue();
                }
            );
        }

        /**
         * Fügt eine Genehmigungsanfrage zur Warteschlange hinzu.
         * Die Anfrage wird asynchron verarbeitet und wartet auf Benutzer-Entscheidung.
         * 
         * @param {object} request - Die NIP-46 request mit {method, pubkey, params}
         * @returns {Promise<boolean>} true wenn genehmigt, false wenn abgelehnt
         */
        function requestPermission(request) {
            return new Promise((resolve) => {
                pendingPermissionRequests.push({ request, resolve });
                processPermissionQueue();
            });
        }

        // ===== NIP-46 Backend RPC Relay Management =====
        // Verwaltet die Verbindung zu Relays für NIP-46 RPC-Kommunikation mit Clients
        // Sichert sicher, dass mindestens ein Relay verbunden ist
        
        /**
         * Zählt die Anzahl der verbundenen RPC-Relays im NIP-46 Backend.
         * Ein Relay ist verbunden wenn sein Status === 5 (CONNECTED in NDK).
         * 
         * @param {NDKNip46Backend} nip46Backend - Das NIP-46 Backend Objekt
         * @returns {number} Anzahl der verbundenen Relays (0 wenn keine vorhanden)
         */
        function connectedBackendRpcRelayCount(nip46Backend) {
            const relaysMap = nip46Backend?.rpc?.pool?.relays;
            if (!relaysMap || typeof relaysMap.values !== "function") return 0;
            return Array.from(relaysMap.values()).filter((relay) => relay?.status === 5).length;
        }

        /**
         * Stellt sicher dass mindestens minConnected Relays verbunden sind.
         * Wartet bis zum Timeout auf Relay-Verbindungen.
         * 
         * @param {NDKNip46Backend} nip46Backend - Das NIP-46 Backend Objekt
         * @param {number} timeoutMs - Timeout in Millisekunden (default: 7000)
         * @param {number} minConnected - Minimum erforderliche verbundene Relays (default: 1)
         * @throws {Error} Wenn Timeout auftritt oder zu wenige Relays verbunden sind
         */
        async function ensureBackendRpcRelaysConnected(nip46Backend, timeoutMs = 7000, minConnected = 1) {
            const rpcPool = nip46Backend?.rpc?.pool;
            if (!rpcPool || typeof rpcPool.connect !== "function") return;

            await Promise.race([
                rpcPool.connect(timeoutMs),
                new Promise((_, reject) => setTimeout(() => reject(new Error("rpc pool connect timeout")), timeoutMs + 1000))
            ]);

            const connected = connectedBackendRpcRelayCount(nip46Backend);
            if (connected < minConnected) {
                throw new Error(`Signer RPC relays offline (${connected}/${minConnected})`);
            }
        }

        /**
         * Patcht den NIP-46 RPC um Relay-Verbindungen vor Requests zu checksieren.
         * Dies verhindert dass Requests auf Offline-Relays fehlschlagen.
         * 
         * Patcht folgende Methoden:
         * - sendResponse: Stellt sicher dass mindestens 1 Relay connected ist vor Response
         * - sendRequest: Stellt sicher dass mindestens 1 Relay connected ist vor Request
         * 
         * @param {NDKNip46Backend} nip46Backend - Das NIP-46 Backend Objekt zu patchen
         */
        function patchBackendRpcReliability(nip46Backend) {
            const rpc = nip46Backend?.rpc;
            if (!rpc || rpc.__reliabilityPatched) return;

            const originalSendResponse = rpc.sendResponse?.bind(rpc);
            if (typeof originalSendResponse === "function") {
                rpc.sendResponse = async (...args) => {
                    await ensureBackendRpcRelaysConnected(nip46Backend, 7000, 1);
                    return originalSendResponse(...args);
                };
            }

            const originalSendRequest = rpc.sendRequest?.bind(rpc);
            if (typeof originalSendRequest === "function") {
                rpc.sendRequest = async (...args) => {
                    await ensureBackendRpcRelaysConnected(nip46Backend, 7000, 1);
                    return originalSendRequest(...args);
                };
            }

            rpc.__reliabilityPatched = true;
        }

        /**
         * Prüft ob ein Unlock-Fehler wiederholbar ist (sollte erneut versucht werden).
         * Nicht-wiederholbare Fehler sind definitiv falsch (z.B. ungültiger nsec Format).
         * Wiederholbare Fehler sind Validierungsfehler die durch Benutzereingabe korrigiert werden können.
         * 
         * @param {Error} err - Der zu prüfende Error
         * @returns {boolean} true wenn der Fehler wiederholbar ist
         */
        function isRetryableUnlockError(err) {
            const msg = err?.message || "";
            return msg === "Kein Passwort angegeben." ||
                msg === "Kein nsec angegeben." ||
                msg === "Passwörter stimmen nicht überein." ||
                msg === "Entsperren fehlgeschlagen. Passwort oder Daten sind ungültig." ||
                msg === "Migration fehlgeschlagen. Passwort oder Alt-Daten sind ungültig." ||
                msg.startsWith("Passwort muss mindestens ") ||
                msg.startsWith("Ungültiger nsec");
        }

        /**
         * Ruft getOrAskActiveKey auf und wiederholt bei wiederholbaren Fehlern.
         * Zeigt Benutzern die Möglichkeit Fehler zu korrigieren (z.B. Passwort erneut eingeben).
         * Nicht-wiederholbare Fehler werden geworfen.
         * 
         * @returns {Promise<object>} Das entsperrte Schlüsselobjekt
         * @throws {Error} Bei nicht-wiederholbarem Fehler
         */
        async function getOrAskActiveKeyWithRetry() {
            while (true) {
                try {
                    return await getOrAskActiveKey();
                } catch (err) {
                    if (err?.message === "Entsperren abgebrochen.") throw err;
                    if (!isRetryableUnlockError(err)) throw err;
                    appendRequestLog(`${err.message} Bitte erneut versuchen.`);
                }
            }
        }

        // ===== NIP-46 Signer Startup und Initialisierung =====
        // Haupteinstiegspunkt: Initialisiert NDK, entsperrt Schlüssel, startete NIP-46 RPC-Backend
        
        /**\n         * KRITISCHE FUNKTION: Initialisiert und startet den kompletten NIP-46 Signer.\n         * Dies ist der Einstiegspunkt am Ende des Skriptes.\n         * \n         * Prozess (in Reihenfolge):\n         * 1. NDK mit RELAYS initialisieren\n         * 2. Benutzer-Entsperrrung (mit Retry bei Validierungsfehlern)\n         * 3. Aktiven Schlüssel laden und NDKUser erstellen\n         * 4. Bunker/Nostrconnect URIs generieren\n         * 5. Verbindungsinformationen für Parent bereitstellen\n         * 6. UI aktualisieren (Status, User-Info, ConnectionInfo)\n         * 7. NIP-46 NDKNip46Backend initialisieren mit Permission-Callback\n         * 8. RPC-Relay-Zuverlässigkeit patchen\n         * 9. Relay-Verbindungen gewährleisten\n         * 10. \"ready\" Message an Parent senden\n         * \n         * Permission-Callback logik:\n         * - switch_relays: BLOCKIERT (feste Allowlist)\n         * - AUTO_ALLOW_METHODS: Auto erlaubt (connect, ping, get_public_key)\n         * - Nicht-sensible Methoden: Auto erlaubt\n         * - SENSITIVE_METHODS mit TTL-Genehmigung: Erlaubt wenn noch nicht abgelaufen\n         * - SENSITIVE_METHODEN ohne TTL: Frage Benutzer via Modal\n         * \n         * @throws {Error} Bei Entsperrrung fehlgeschlagen, NDK/Relay Fehler, oder NIP-46 Backend Start Fehler\n         */
        async function startSigner() {
            const ndk = new NDK({ explicitRelayUrls: RELAYS });
            await ndk.connect();

            const unlocked = await getOrAskActiveKeyWithRetry();
            sessionPassword = unlocked.password;
            currentKeyring = unlocked.keyring;
            activeKeyId = unlocked.keyId;
            activeNsec = unlocked.nsec;

            const localSigner = new NDKPrivateKeySigner(activeNsec);
            const user = await localSigner.user();
            activeUser = user;

            const relayQuery = RELAYS.map((relayUrl) => `relay=${encodeURIComponent(relayUrl)}`).join("&");
            const bunkerUri = `bunker://${user.pubkey}?${relayQuery}`;
            const nostrconnectUri = `nostrconnect://${user.pubkey}?${relayQuery}`;
            connectionInfo = {
                pubkey: user.pubkey,
                npub: user.npub,
                keyName: unlocked.keyName,
                relays: RELAYS,
                bunkerUri,
                nostrconnectUri
            };

            document.getElementById("status").innerText = "Signer bereit";
            document.getElementById("user-info").innerText =
                `Aktiver Schlüssel: ${unlocked.keyName}\n` +
                `npub: ${user.npub.substring(0, 16)}...\n` +
                "Warte auf NostrConnect-Anfragen.";
            document.getElementById("connection-info").innerText =
                `Aktiver Schlüssel: ${unlocked.keyName}\n` +
                `pubkey: ${user.pubkey}\n` +
                `npub: ${user.npub}\n` +
                `Relays: ${RELAYS.join(", ")}\n` +
                `Bunker URI: ${bunkerUri}\n` +
                `Nostrconnect URI: ${nostrconnectUri}`;

            renderKeyManager();
            setActiveTab("signer");
            setCompactConnectedMode(isEmbeddedContext);

            const nip46Backend = new NDKNip46Backend(
                ndk,
                localSigner,
                async (request) => {
                    console.log("NIP-46 Anfrage:", request);
                    const method = request?.method;
                    const pubkey = request?.pubkey ?? "";
                    appendRequestLog(`Methode: ${method} von ${pubkey.slice(0, 12) || "?"}...`);

                    if (method === "switch_relays") {
                        appendRequestLog("Blockiert: switch_relays (feste Relay-Allowlist)");
                        return false;
                    }

                    if (AUTO_ALLOW_METHODS.has(method)) {
                        appendRequestLog(`Auto erlaubt: ${method}`);
                        return true;
                    }

                    if (!SENSITIVE_METHODS.has(method)) {
                        appendRequestLog(`Nicht sensitiv, erlaubt: ${method}`);
                        return true;
                    }

                    if (pubkey && hasActivePermission(pubkey, method)) {
                        appendRequestLog(`TTL erlaubt: ${method}`);
                        return true;
                    }

                    return requestPermission(request);
                },
                RELAYS
            );

            patchBackendRpcReliability(nip46Backend);
            await nip46Backend.start();
            await ensureBackendRpcRelaysConnected(nip46Backend, 9000, 1);
            appendRequestLog("Signer RPC verbunden.");
            postBridgeMessage("ready", connectionInfo);
            appendRequestLog("Bridge: ready an Parent gesendet");
            console.log("Bunker URI:", bunkerUri);
            console.log("Nostrconnect URI:", nostrconnectUri);
        }

        // ===== Modal UI Hilfsfunktionen =====
        
        /**
         * Erzeugt einen benutzerfreundlichen Titel für eine NIP-46 Request-Methode.
         * Wird im Modal als Fragestellung angezeigt.
         * 
         * @param {string} method - Die NIP-46 Methodenname
         * @returns {string} Ein benutzerfreundlicher Titel (z.B. "Signieren und senden?")
         */
        function humanRequestTitle(method) {
            if (method === "sign_event") return "Signieren und senden?";
            if (method === "connect") return "Verbindung erlauben?";
            if (method === "get_public_key") return "Öffentlichen Schlüssel teilen?";
            if (method === "nip04_encrypt" || method === "nip44_encrypt") return "Verschlüsseln erlauben?";
            if (method === "nip04_decrypt" || method === "nip44_decrypt") return "Entschlüsseln erlauben?";
            return `Anfrage: ${method}`;
        }

        /**
         * Zeigt ein Modal-Fenster für eine NIP-46 Genehmigungsanfrage.
         * Der Benutzer kann "einmal erlauben", "immer erlauben" oder "ablehnen" auswählen.
         * 
         * @param {object} req - Die NIP-46 Request mit method, pubkey, params
         * @param {function} onAllowOnce - Callback für "einmal erlauben" (this session only)
         * @param {function} onAllowAlways - Callback für "immer erlauben" (permanent)
         * @param {function} onReject - Callback für "ablehnen"
         */
        function showModal(req, onAllowOnce, onAllowAlways, onReject) {
            document.getElementById("request-title").innerText = humanRequestTitle(req.method);
            document.getElementById("request-details").innerText =
                `Methode: ${req.method}\nParameter: ${formatRequestParams(req)}`;

            document.getElementById("overlay").style.display = "block";
            document.getElementById("auth-modal").style.display = "block";
            scheduleFrameSizeNotification(true);

            document.getElementById("allow-once-btn").onclick = () => {
                hideModal();
                onAllowOnce();
            };

            document.getElementById("allow-always-btn").onclick = () => {
                hideModal();
                onAllowAlways();
            };

            document.getElementById("reject-btn").onclick = () => {
                hideModal();
                onReject();
            };
        }

        /**
         * Versteckt das Modal-Fenster und Overlay.
         */
        function hideModal() {
            document.getElementById("overlay").style.display = "none";
            document.getElementById("auth-modal").style.display = "none";
            scheduleFrameSizeNotification(true);
        }

        // ===== Initialization und Event Listener Setup =====
        // Diese Zeilen richten alle Event-Listener auf und starten den Signer
        
        setupTabNavigation();
        setupKeyManagerHandlers();
        setupFrameAutoResizeBridge();
        window.addEventListener("message", bridgeMessageHandler);

        /**
         * Startet den kompletten Signer Prozess.
         * Bei Fehler wird die Fehlermeldung im Status-Display angezeigt.
         */
        startSigner().catch((err) => {
            console.error(err);
            setCompactConnectedMode(false);
            document.getElementById("status").innerText = `Fehler: ${err.message}`;
        });
    </script>
</body>
</html>

